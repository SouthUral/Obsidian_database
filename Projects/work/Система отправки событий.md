#проекты
#work 

Статус:: "на паузе"
### Задача
Нужна событийная система, сервисы должны отправлять событие, другие сервисы могут эти события перехватывать для своей логики. Так же нужна система для хранения событий

### Основные компоненты
- Сервис сохранения всех сообщений;
	- сервис создает Exchange (1 или 2)
	- этот сервис имеет свою БД и записывает туда все события;
	- в теории он может выдать эти события обратно в событийную систему;
- Rabbit c exchange;
- Отправители (отправляют сообщения `события` в RabbitMQ);
- Получатели (получают сообщения из RabbitMQ)

### Этапы решения задачи
1. [ ] Реализовать менеджера получателей. В менеджер получателей приходят события от обработчиков gRPC с несколькими типами сообщений. Нужно сделать реакцию на каждый тип сообщения.
	1. [ ] Нужна система регистрации внутренних подписчиков. Это должна быть хэш таблица, в которую должны сохранятся проинициализированные экземпляры [внутренних потребителей]. Для хранения нужно в качестве ключа использовать хэш произведенный из 
	2. Тип сообщения ==новая подписка==:
		1. [ ] Поиск __внутреннего получателя__ по переданной конфигурации. 
			1. [ ] Если получатель найден:
				 - [x] вызов метода для добавления нового внешнего потребителя внутреннему получателю.
			2.  [ ] Если получатель не найден:
				 - [ ] инициализация получателя,
				 - [ ]  вызов метода для добавления нового внешнего потребителя внутреннему получателю.
	3.  [ ] Тип сообщения ==остановка подписчика== возникает когда внешний подписчик отваливается или заканчивается время ожидания у обработчика gRPC:
		1. [x] Поиск по конфигу нужного отправителя и вызов у него метода остановки промежуточного подписчика (нужно передать имя подписчика)
	4. В начале работы менеджер получателей должен запросить состояние у модуля работы с состоянием.
		1. Передается запрос в модуль состояния.
		2. В модуле состояние делается запрос через модуль БД к самой БД
			1. Если данные есть:
				1. данные возвращаются по каналу в менеджер получателей (менеджер получателей должен ждать ответа)
				2. менеджер получателей создает по полученным данным внутренние очереди (внутренних потребителей) инициализируя их.
					1. в функцию инициализации передается список подписчиков (подписчики будут добавлены в список спящих потребителей, т.е. просто создана структура с именем и оффсетом)
			2. Если данных нет:
				1. менеджер получателей просто переходит в режим ожидания событий от API
3. Реализация внутреннего получателя:
	-  Внутреннему получателю нужны списки (словари) активных подписчиков и спящих подписчиков. 
	-  Метод остановки внутреннего подписчика `sleepConsumer` вызывает метод остановки всех процессов у промежуточного подписчика и перемещает его из списка активных подписчиков в список спящих.
4.  Нужен механизм сохранения состояния. Это должен быть отдельный модуль который подключается к БД и по запросу от модулей, которым нужно сохранять свое состояние, отправлять состояние в БД. У модуля должен быть метод для восстановления состояния системы. Он должен запускаться сразу после запуска сервиса.
	1. В состоянии нужно хранить всех внутренних подписчиков с их конфигом. 
	2. Нужно хранить всех промежуточных подписчиков (имя подписчика, offset последнего не переданного события)
	3. Сохранение состояния должно быть асинхронным, т.е. каждый элемент, которому нужно свое состояние должен сам его сохранять, т.к. есть элементы у которых состояние меняется постоянно, и есть элементы у которых состояние меняется редко.
	4. Нужен метод для восстановления состояния сервиса, он должен быть запущен сразу после запуска сервиса.
Пример структуры
```json
[
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_1": "last_offset",
			"consumer_2": "last_offset",
		},
	},
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_5": "last_offset",
			"consumer_6": "last_offset",
		},
	},
]

```
4. [ ] Нужен механизм сохранения событий, которые попадают во внутренний получатель, в БД:
	1. Нужно определиться со структурой БД. Надо понять, создавать ли для каждой очереди свою таблицу, или записывать все очереди в одну таблицу разделенную по партициям;
	2. Нужен механизм записи события очереди в БД
5. [ ] Нужен механизм восстановления очереди, при переподключении внешнего потребителя (т.е. перевод промежуточного потребителя из спящего состояния в активное)
	1. Механизм перевода промежуточного потребителя из спящего состояния в активное. 
		1. При восстановлении пропущенных событий:
			1. Запуск внутренней очереди
			2. Чтение оффсета первого элемента очереди
			3. Отправка запроса через модуль работы с состоянием на все данные по текущей очереди начиная со старого оффсета и заканчивая новым.
			4. Скорее всего возвращать все данные разом не нужно, лучше возвращать их чанками через канал, чтобы не забивать локальный кэш

# Основные задачи

## Получение данных о работе очередей и exchanges
Нужно сделать функционал для вывода мониторинга работы очередей, основные показатели мониторинга:
- количество входящих событий в единицу времени;
- количество событий которое отдано в единицу времени;
- наполнение очереди (в процентах);
- активное или неактивное состояние очередей (показать обрыв связи)

## Команда API для создания только Exchange (без очереди)
## Сохранение/восстановление состояния 

### Модуль _consumerManagement_

Нужно понять, сколько каналов нужно для общения с модулем состояния.
Основные задачи по работе с состоянием в этом модуле:
- запросы на получение данных:
	- запрос на восстановление состояния, производится из _менеджера потребителей_;
	- запрос на получение очереди из БД, производится конкретной очередью;
- отправка данных:
	- сохранение события, производится из _exchange_;
	- сохранение новой очереди;
	- сохранение offset события, который был передан внешнему потребителю, отправляет queue.

Событие которое передается из _exchange_ имеет структуру ==СОХРАНЕНИЕ==:
 - id события;
 - id exchange;
 - offset exchange;
 Благодаря такому подходу, само тело события будет сохранено в БД лишь один раз при поступлении от отправителя.

Событие ==СОХРАНЕНИЯ== данных о новой очереди:
- idQueue `UUID`
- idExchange `UUID`
- nameQueue `string`
- limitSize `int`

Структура сообщения от queue для сохранения offset переданного события ==СОХРАНЕНИЕ==:
- idQueue `UUID`
- offsetEvent `int`
Нужно подумать что необходимо для получения очереди, проблема в том, что может прийти запрос на восстановление очереди еще до возникновения _exchange_. Т.е. запрос на восстановление очереди событий с конфигрурацией, с датой начала еще до момента регистрации exchange в маршрутизаторе.

Структура сообщения для восстановления очереди ==ПОЛУЧЕНИЕ==:
1) Вариант стандартный если запрос с API пришел без параметров а очередь уже была создана:
	- offset последнего переданного сообщения (от какого события);
	- offset сообщения которое только что было получено (до какого события) (нужно для получения конечного количества событий);
	- id очереди;
2) Вариант когда пришел offset от API:
	- offset от API (от какого события);
	- offset сообщения которое только что было получено (до какого события);
	-  id очереди;
3) Вариант восстановления очереди с указанием времени от API:
	- time время от API от какого времени нужны события;
	- offset сообщения которое только что было получено (до какого события);
	- id очереди;
	В этом случае есть проблема, если время будет указано до создания exchange то события до создания просто не попадут в выборку. Для выборки которая будет удовлетворять конфигурации exchange нужно сделать запрос в БД с указанием всех необходимых типов событий.

Так же может прийти запрос от внешнего получателя на запуск очереди без восстановления. Тогда надо просто запустить очередь

Структура события для восстановления состояния _менеджера потребителей_ ==ПОЛУЧЕНИЕ==.
Для этого не требуются какие либо параметры. Т.к. в любом случае будет исполнен запрос без параметров.

# Структура таблиц в БД
![[Pasted image 20240115133351.png]]

# Задачи
- [ ] Сделать описание, что сделано и что нужно сделать 📅 2024-02-03
- [ ] Выписать список всех данных состояния которые нужно будет мониторить 📅 2024-02-05

# Заметки по проекту
Можно разбить проект на несколько микросервисов.
1) Мискросервис который принимает события от отправителей, записывает их в БД и отправляет по gRPC сервису маршрутизатору;
2) Сервис маршрутизатор (текущая разработка) распределяет события по потокам и управляет обменниками (exchange) и очередями (queue) потребителей. К нему подключаются потребители по протоколу gRPC (канал передачи данных), так же нужно реализовать передачу данных через REST API в формате запрос события -> ответ. Сервис сохраняет свое состояние (имеет модуль для работы с БД) так же сервис имеет интерфейс (API или gRPC) для отдачи состояния и возможно в будущем для управления очередями и обменниками. Нужно продумать восстановление состояния, когда нужно подтянуть сырые события из БД и прогнать их через маршрутизатор.
	1) Нужно сделать сервис в двух видах:
		1) Сервис как монолит, сам получает события от отправителей, сам их сохраняет в БД, сам маршрутизирует их и отправляет получателям. В таком виде есть вероятность аварийного завершения программы с потерей событий от отправителей. Так же сервис сам авторизует подключения. 
			1) Нужно реализовать API для добавления или удаления пользователя;
			2) Нужно сделать авторизацию через gRPC для того чтобы левый отправитель или получатель не могли подцепиться к сервису.
		2) Сервис как монолит, занимается только маршрутизацией и отправкой событий потребителям. Получает события по gRPC протоколу от сервиса сохранения событий в БД.
3) Сервис GateWay нужен как общая точка входа, куда отправляют события отправители, он же занимается авторизацией, он же принимает сообщения от получателей. Через GateWay производится доступ к инструменту мониторинга.
	1) Возможно нужно сделать сервис для Авторизации и Аутентификации.
4) Сервис мониторинга (Front) это GUI сервис, показывает метрики сервиса маршрутизатора, так же через этот сервис можно добавить Echange, и добавить либо удалить пользователя.