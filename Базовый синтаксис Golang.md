[[Golang]]

## Оглавление:
- [[Базовый синтаксис Golang#Переменные|Переменные]]
- [[Базовый синтаксис Golang#Функции|Функции]]
	- [[Базовый синтаксис Golang#Анонимные функции|Анонимные функции]]
- [[Базовый синтаксис Golang#Числа и операции над ними|Числа и операции над ними]]
	- [[Базовый синтаксис Golang#Арифметические операции|Арифметические операции]]
- [[Базовый синтаксис Golang#Логические типы|Логические типы]]
- [[Базовый синтаксис Golang#Строки|Строки]]
- [[Базовый синтаксис Golang#Операторы управления потоком|Операторы управления потоком]]
	- [[Базовый синтаксис Golang#Условные конструкции|Условные конструкции]]
	- [[Базовый синтаксис Golang#Switch|Switch]]
	- [[Базовый синтаксис Golang#Defer|Defer]]
- [[Базовый синтаксис Golang#Структуры|Структуры]]
	- [[Базовый синтаксис Golang#Композиция|Композиция]]
	- [[Базовый синтаксис Golang#Встраивание|Встраивание]]
- [[Базовый синтаксис Golang#Константы|Константы]]
- [[Базовый синтаксис Golang#Массивы|Массивы]]
- [[Базовый синтаксис Golang#Слайсы|Слайсы]]
	- [[Базовый синтаксис Golang#Копирование слайсов|Копирование слайсов]]
	- [[Базовый синтаксис Golang#Сортировка слайсов|Сортировка слайсов]]
- [[Базовый синтаксис Golang#Цикл For|Цикл For]]

---

## Переменные

Go статически типизирован. Переменные объявляются явно, тип переменной заранее известен компилятору.
Существует два способа объявить переменную:

1) Длинная запись с ключевым словом var:
```go
var num int = 10
```
    
2) Короткая запись:
```go
num := 10
```

Значение переменной можно изменять в любой момент, но в нее нельзя записать данные другого типа

Переменные принято называть в camelCase

Если не задавать значение переменной при инициализации она будет иметь нулевое значение:
```go
var (
	a string // ""
	b bool // false
	c int // 0
)
```


Переменные можно объявлять на уровне функций или пакетов
Именовать переменные нужно как можно короче (сокращать)

---

## Функции

Функции в Go объявляют через ключевое слово func:
```go
func miltiply(x int, y int) int {
	return x * y
}
```

Тип аргументов пишется после названия переменной
Если несколько аргументов подряд имеют один и тот же тип то можно написать сокращенно:
```go
func multiply(x, y int) int {

}
```
   
После скобок с аргументами пишется тип возвращаемого значения

Если функция именованна с заглавной буквы то эта функция доступна вне пакета (она экспортируется, те. публичная),
если начинается со строчной то это функция используется только локально в рамках пакета:
```go
package math

// можно вызвать извне как math.Multiply(4, 5)
func Multiply(x, y int) int {
	return x * y
}

// приватная функция, извне не вызвать
func devide(x, y int) int {

}
```

Из одной функции можно возвращать несколько значений, чаще всего используется для ошибок:
```go
package math

import "errors"

func divide(x, y int) (int, error) {
	if y == 0 {
		return 0, errors.New("cannot divide on zero")
	}

	return x / y, nil
}
```

Возвращаемые значения могут быть именованными:
```go
func multiply(x, y int) (res int) {
	res = x * y
	return 
}
```

Использовать именованные возвращаемые аргументы плохая практика
	1) увеличивается сложность чтения кода;
	2) переменная может быть несколько раз определена в теле функции, что может привести к неожиданному поведению;
	3) пустой return неявно возвращает аргументы.

### Анонимные функции

Go поддерживает анонимные функции. Работают они как обычные, но не имеют названия (как лямбды в питоне или стрелочные функции в js).

Чаще всего анонимные функции используют, чтобы вернуть из функции другую функцию. В примере ниже intSeq() возвращает функцию-генератор, которая при каждом вызове выдает очередное значение счетчика i. Генератор использует переменную, определенную во внешней функции — то есть образует замыкание (closure):
```go
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}
```

Результат вызова intSeq() — функцию-генератор — мы записываем в переменную next. У next собственное значение счетчика i, которое увеличивается при каждом вызове:
```go
next := intSeq()

fmt.Println(next())
// 1
fmt.Println(next())
// 2
fmt.Println(next())
// 3
```

Если создать еще один генератор — он будет обладать собственным счетчиком i:
```go
gen := intSeq()
fmt.Println(gen())
// 1
fmt.Println(gen())
// 2
```

Иногда анонимную функцию передают как аргумент другой функции. Пример из пакета sort :
```go
func Search(n int, f func(int) bool) int
```

Search() находит наименьшее i из диапазона [0, n), для которого функция-предикат f(i) вернет true. В качестве предиката удобно использовать анонимную функцию:

```go
a := []int{1, 2, 4, 8, 16, 32, 64, 128}
x := 53

// ближайший сверху к `x` элемент среза `a`
closest := sort.Search(len(a), func(i int) bool { return a[i] >= x })

fmt.Println(a[closest], "is the closest to", x)
// 64 is the closest to 53
```
---

## Числа и операции над ними

>[!info] В Go представлено много числовых типов данных: 
>
	- uint,
	- uint8,
	- uint16,
	- uint32,
	- uint64,
	- int,
	- int8,
	- int16,
	- int32,
	- int64,
	- float32,
	- float64,
	- complex64,
	- complex128

В ежедневной работе используются только:

- ==int== - основной кроссплатформенный тип целых чисел, может быть отрицательным;

- ==int64==  нужен для больших чисел  из внешних систем. Например, ID в СУБД имеет тип bigint.
    чтобы правильно распарсить такой ID используется int64;

- ==float64== число с плавающей точкой. Чаще всего используется для математических операций
    например функция math.Max(), определяющая наибольшее число, принимает аргументы в виде float64;

### Арифметические операции

В GO имеется стандартный набор арифметических операций:
```go

x := 10
y := 5

x + y // 15

x - y // 5

x / y // 2

x * y // 50
```

Любые операции осуществляются только над числами одинакового типа:
```Go

x := 5.05
y := 10

x + y  // invalid operation: x + y (mismatched types float64 and int)
```

Чтобы осуществить такое сложение нужно сконвертировать значения к одному типу:
```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

При приведении к одному типу есть ряд ньюансов:
```go

// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```
---

## Логические типы

Логический тип в Go представлен привычными значениями true и false c операторами:

- && (and)

- == (равно)

- || (или)

- ! (не)

Объявление переменных происходит через ключевое слово bool:
```go

var b bool = true
bs := false
```


>[!info] Из-за строгой типизации в Go можно сравнивать только одинаковые типы данных:
>```go
>
>true == false // false
>false == false // true
>```
>Т.е. нельзя сравнить пустую строку с false
Пример проверки строки на пустую:
>```go
flag := true
text := "hello"
>flag && text != "" // true

---

## Строки 

Строки в Go объявляются с типом string:

```go

var s string = "text"
s := "text"
```

Практически всегда используются двойные кавычки. Однако они не подходят когда нужно написать несколько строк.
Для этого используют обратные кавычки:
```go

q := `
	SELECT *
	FROM person
	WHERE age > 18
`
```
 
Строки можно сравнивать операторами:

- == 
- > строка1 больше строки2 если строка2 меньше размером и является подстрокой строки1
- <
- <=
- >=

Базовые операции со строками это ==конкатенация== и ==интерполяция==:
```go

"hello " + "world" // "hello world"
```

В Go нет привычной интерполяции, как в динамических языках. Она реализуется через форматирующую функцию ==fmt.Sprintf()==:

```go

username := "Ivan"
greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

Узнать длину строки можно с помощью встроенной функции ==len()==:

```go
len("go") // 2
```

>[!info] Будьте внимательны!
> Функция len() считает кол-во байт, а не кол-во символов
 >   ```go
 >   len("го") // 4
 >   ```

---

## Операторы управления потоком

### Условные конструкции

Условия в Go представлены обычным блоком if else. В условии должно быть строго выражение логического типа.
Пример:
```go

package main

import (
	"fmt"
	"strings"
)

func statusByName(name string) string {
	// функция проверяет, что строка name начинается с подстроки "Mr."
	if strings.HasPrefix(name, "Mr.") {
		return "married man"
	} else if strings.HasPrefix(name, "Mrs.") {
		return "married woman"
	} else {
		return "single person"
	}
}

func main() {
	n := "Mr. Doe"
	fmt.Println(n + " is a " + statusByName(n)) // Mr. Doe is a married man

	n = "Mrs. Berry"
	fmt.Println(n + " is a " + statusByName(n)) // Mrs. Berry is a married woman

	n = "Karl"
	fmt.Println(n + " is a " + statusByName(n)) // Karl is a single person
}
```
---

### Switch
В Go есть альтернатива if - конструкция switch. Когда срабатывает условие какого-либо case, программа
выполняет блок и выходит из конструкции switch без необходимости писать break:
```go

x := 10

switch x {
	default: // default всегда выполняется последним независимо от расположения и конструкции
		fmt.Println("default case")
	case 10:
		fmt.Println("case 10")
}
```

Однако при необходимости можно реализовать логику С-подобных языков и провалится в следующий case:

```go
switch { // выражение отсутствует. Для компилятора выглядит как: switch true
	default:
		fmt.Println("default case")
	case x == 10:
		fmt.Println("equal 10 case")
		fallthrough // игнорирует условние и сразу выполняет тело
	case x <= 10:
		fmt.Println("less or equal 10 case")
}
```
Output:
```go
equal 10 case
less or equal 10 case
```

Еще один пример Case:

Напишите программу, которая определяет название языка по его коду. Правила:

en → English
fr → French
ru или rus → Russian
иначе → Unknown

```go

package main

import (
	"fmt"
)

func main() {
	var code string
	fmt.Scan(&code)

	// определите полное название языка по его коду
	// и запишите его в переменную `lang`
	// ...
	var lang string

	switch code {
	case "en":
		lang = "English"
	case "fr":
		lang = "French"
	case "ru", "rus":
		lang = "Russian"
	default:
		lang = "Unknown"
	}
	
	fmt.Println(lang)
}
```
---

### Defer

Оператор **defer** откладывает выполнение функции до того момента, как произойдет возврат из окружающей функции.

Аргументы отложенных вызовов вычисляются сразу же, но вызов функции не происходит до того, как произойдет возврат из окружающей функции.

```go
package main

import "fmt"

func main() {
    defer fmt.Println("world")

    fmt.Println("hello")
}

//hello
//world
```

#### Накопление отложенных вызовов

Отложенные вызовы функций сохраняются в стеке. Когда происходит возврат из функции, ее отложенные вызовы выполняются в порядке "последним-пришел-первым-вышел" ==(LIFO, last-in-first-out)==.
```go
package main

import "fmt"

func main() {
    fmt.Println("Подсчет...")

    for i := 0; i < 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println("выполнен")
}
```
Вывод:
```bash
Подсчет...
выполнен
9
8
7
6
5
4
3
2
1
0
```

---

## Структуры

В Go нет классов и привычной реализации ООП. Вместо классов в языке используются структуры -
наборы полей, имеющих название и тип данных. Объявление структуры:
```Go
type Person struct {
	// [название поля] [тип данных]
	Name string
	Age int
}

func main() {
	p := Person{Name: "John", Age: 25}

	p.Name // "John"
	p.Age // 25
}
```

Структуру можно инициализировать не передавая значения. В этом случае каждое поле примет свое нулевое значение

Регистр первой буквы в названии структуры и полей означает публичность, точно так же, как в переменных и функциях. Если первая буква заглавная,
то структуру можно инициализировать во внешних пакетах. Иначе она доступна только в пределах текущего пакета.

```Go
type Person struct { // структура публична
    Name string // поле публично
    wallet wallet // поле приватно: можно обращаться только внутри текущего пакета
    }

type wallet struct { // структура приватна: можно инициализировать только внутри текущего пакета
    id string
    moneyAmount float64
    }
```


У любого поля структуры можно указать теги. Они используются для метаинформации о поле для сериализации,  
валидации, маппинга данных из БД и т.д. Тег указывается после типа данных через бектики:

```go

type User struct {
	ID int64 `json:"id" validate:"required"`
	Email string `json:"email" validate:"required,email"`
	FirstName string `json:"first_name" validate:"required"`
}
```


Тег json используется для названий полей при сериализации/десериализации структуры в json и обратно:
```go

package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	ID        int64  `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
}

func main() {
	u := User{}
	u.ID = 22
	u.Email = "test@test.com"
	u.FirstName = "John"

	bs, _ := json.Marshal(u)

	fmt.Println(string(bs)) // {"id":22,"email":"test@test.com","first_name":"John"}
}
```

>[!info] json.Marshal()
>функция `json.Marshal()` преобразует структуру в json


Тег validate используется Go-валидатором. Пример вызова функции структур:

```go

package main

import (
	"fmt"
	"github.com/go-playground/validator/v10"
)

type User struct {
	ID        int64  `validate:"required"`
	Email     string `validate:"required,email"`
	FirstName string `validate:"required"`
}

func main() {
	// создали пустую структуру, чтобы проверить валидацию
	u := User{}

	// создаем валидатор
	v := validator.New()

	// метод Struct валидирует переданную структуру и возвращает ошибку `error`, если какое-то поле некорректно
	fmt.Println(v.Struct(u))
}
```


### Композиция

В Go нет наследования. Вместо него активно используется композиция — когда новое поведение собирают из кирпичиков существующего.

Есть тип «счетчик»:
```go
type counter struct {
	value uint
}
```

Его можно увеличивать на единицу:
```go
func (c *counter) increment() {
	c.value++
}
```


Или на указанное число:
```go
func (c *counter) incrementDelta(delta uint) {
	c.value += delta
}
```

Мы хотим замерять использование сервисов. Чтобы не дублировать существующие функции, добавим счетчик в тип «использование сервиса»:
```go
    type usage struct {
        service string
        counter counter
    }

    func makeUsage(service string) usage {
        return usage{service, counter{}}
    }
```

Будем мерить использование сервиса, увеличивая его счетчик:
```go
usage := makeUsage("find")
usage.counter.increment()
usage.counter.increment()
usage.counter.increment()
fmt.Printf("%s usage: %d\n", usage.service, usage.counter.value)
// find usage: 3
```

Для типа «просмотры страницы» тоже добавим счетчик:
```go
type pageviews struct {
	url *url.URL
	counter counter
}

func makePageviews(uri string) pageviews {
	u, err := url.Parse(uri)
	if err != nil {
		log.Fatal(err)
	}
	return pageviews{u, counter{}}
}
```

И будем мерить просмотры:
```go
pv := makePageviews("/doc/find")
pv.counter.incrementDelta(100)
fmt.Printf("%s views: %d\n", pv.url, pv.counter.value)
// /doc/find views: 100
```

### Встраивание

Все хорошо, но несколько неудобно было писать usage.counter.increment() на предыдущем шаге. По-хорошему, usage  расширяет counter — отношение между ними больше похоже на наследование, чем на композицию. В Go в таких случаях используют встраивание (embedding). Посмотрим, как оно работает.

Есть тип «счетчик», такой же, как на предыдущем шаге:
```go
type counter struct {
	value uint
}
func (c *counter) increment() {
	c.value++
}
func (c *counter) incrementDelta(delta uint) {
	c.value += delta
}
```

Мы хотим замерять использование сервисов. Встроим счетчик в тип «использование сервиса»:
```go
type usage struct {
	service string
	counter
}

func makeUsage(service string) usage {
	return usage{service, counter{}}
}
```

Благодаря встраиванию, поля и методы счетчика доступны прямо на usage, без обращения к полю counter:
```go
usage := makeUsage("find")
usage.increment()
usage.increment()
usage.increment()
fmt.Printf("%s usage: %d\n", usage.service, usage.value)
// find usage: 3
```

Аналогично с типом «просмотры страниц»:
```go
type pageviews struct {
	url *url.URL
	counter
}

func makePageviews(uri string) pageviews {
	u, err := url.Parse(uri)
	if err != nil {
		log.Fatal(err)
	}
	return pageviews{u, counter{}}
}
```

Поля и методы счетчика доступны прямо на pageviews:
```go
pv := makePageviews("/doc/find")
pv.incrementDelta(100)
fmt.Printf("%s views: %d\n", pv.url, pv.value)
// /doc/find views: 100
```
---

## Константы

Константы - это постоянные значения, которые инициализируются один раз и не изменяются в течении всего выполнения программы.
Объявление константы:
```go
const [название] [тип данных] = [значение]

const StatusOk int = 200
```

На практике тип данных не указывается, и несколько констант принято объявлять в рамках одного const:
```go
const (
	StatusOk = 200
	StatusNotFound = 404
)
```

>[!info] Только некоторые типы данных можно присвоить константе:  
> -  строки,
> - числа,
> - символы,
> - логический тип.
Регистр первой буквы указывает на публичность/приватность константы.
Константы можно объявлять на уровне функций, либо пакета.

Для последовательных числовых констант следует использовать индентификатор iota, который присвоит для списка чисел значения от 0:
```go
package main

import "fmt"

const (
	zero = iota
	one
	two
	three
)

func main() {
	fmt.Println(zero, one, two, three) // 0 1 2 3
}
```
---

## Массивы

Массив - это коллекция однотипных значений фиксированной длины
```go
nums := [5]int{}
```

Длина массива указывается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:
```go
nums := [5]int{} // [0, 0, 0, 0, 0]

var nums [5]int // [0, 0, 0, 0, 0]
```

При попытке инициализации элементов за границей массива выходит ошибка компиляции:
```go
nums := [1]int{1, 2} // array index 1 out of bounds [0:1]
```

Чтение и запись элементов массива происходит через квадратные скобки:
```go
nums := [3]int{1, 2, 3}

fmt.Println(nums[1]) // 2

nums[2] = 33

fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0. При попытке чтения/записи элементов за границей массива выходит ошибка компиляции:
```go
words := [2]string{}

words[2] // invalid array index 2 (out of bounds for 2-element array)
```

Массивы в Go передаются по значению, следовательно, любое изменение внутри функции не влияет на исходный массив:
```go
package main 

import (
	"fmt"
)

func main() {
	a := [3]int{1, 2, 3}

	midifyArr(a)

	fmt.Println(a) // 1, 2, 3
}

func modifyArr(nums [3]int) {
	nums[0] = 35
}
```

В Go есть встроенная функция len(), которая возвращает длину массива:
```go
fmt.Println(len([5]int{1, 2, 3})) // 5
fmt.Println(len([10]int{})) // 10
```

Массивы одноразмерны, но их можно комбинировать, чтобы получить нужную размерность:
```go
var arr [2][3]int

for i := 0; i < 2; i++ {
	fot j := 0; j < 3; j++ {
		arr[i][j] = i + j
	}
}

fmt.Println("2d:", arr) // 2d: [[0, 1, 2][1, 2, 3]]
```
---

## Слайсы

>[!info] Срез (slice)
>Срез - ключевая структура данных в Go. Это массив изменяемой длины, как list в питоне или Array в js. Обычно в программах на Go оперируют именно срезами, «чистые» массивы встречаются намного реже.

==Слайс - это массив неопределенной длинны (или динамический массив)==
```go
var nums = []int{1, 2, 3}

nums := []int{1, 2, 3}
```

Чтение и запись осуществляется так же как и в массивах:
```go
nums := []int{1, 2, 3}

nums[2] // 3

nums[0] = 10 // [10, 2, 3]

// с помощью оператора : можно получить элементы от нижней до верхней границы

nums[1:3] // [2, 3]

nums[:2] // [10, 2]

nums[2:] // 3
```


В слайсы можно добавлять элементы с помощью встроенной функции func append(slice []Type, elems ...Type) []Type,
которая возвращает новый слайс с добавленным элементом:
```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Помимо самих значений слайс хранит 2 дополнительных свойства:
 - длину массива len(длина)
 - cap(вместимость)
Благодаря этому возможно инициализировать слайс нужной длины с помощью встроенной функции:
```go
func make(t Type, len, cap IntegerType) Type. 
```

==Для начала рекомендуется использовать make везде, где можно:==
```go
// len = 5 Массив будет сразу заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5, массив будет пустым, однако заполнение слайса через append будет эффективным
// потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса как аргумента функции происходит хитро. Длина и вместимость передаются по значению, но 
массив значений передается по ссылке. Вследствие этого получается неявное поведение: добавленные элементы не сохранятся 
в исходный слайс, но изменения существующих останется:
```go
package main

import (
	"fmt"
)

func main() {
	nums := []int{1, 2, 3, 4, 5}

	modifySlice(nums)

	fmt.Println(nums)
}

func modifySlice(nums []int) {
	nums[2] = 10 // элемент будет и в исходном слайсе

	nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Для того чтобы сделать слайс слайсов:
```go
a := make([][]int, 0)
```

Но в таком случае вложенные слайсы так же должны иметь такой же тип данных []int

---

### Копирование слайсов

В языке есть встроенная функция `func copy(dst, src []Type) int`, которая копирует слайс src в слайс dst и возвращает количество
скопированных элементов:
```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

Почему мы не можем просто перезаписать слайс в другую переменную и изменять ее? Как и с функциями, при присваивании слайса к переменной, 
копируется только длина и вместимость, но массив передается по ссылке:
```go
nums := []int{1,2,3,4,5}

numsCp := nums

// исходный слайс nums тоже будет изменен
numsCp[0] = 10

fmt.Println(nums) // [10,2,3,4,5]
```

Существует распространенная ошибка, когда пытаются скопировать слайсы различной длины. 
В этом случае элементы, выходящие за рамки слайса dst, не будут скопированы:
```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

---

### Сортировка слайсов

В го существует готовое решение для сортировки массива. Стандартный пакет sort предоставляет функции для сортировки:
```go
Slice(x interface{}, less func(i, j int) bool)

nums := []int{2, 1, 6, 5, 3, 4}

sort.Slice(nums, func(i, j int) bool {
	return nums[i] < nums[j]
})
```

>[!info] Пустой интерфейс
>Пустой интерфейс в Го означает тип данных, под который подходит любой другой тип

В функцию `Slice(x interface{}, less func(i, j int) bool)` передается слайс любого типа данный, как первый аргумент.
Вторым аргументом передается функция, которая берет элементы по индексу `i` и определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`

Под капотом в функции sort.Slice используется быстрая сортировка. В пакете также присутствует сортировка вставками sort.SliceStable:
```go
nums := []int{2, 3, 1, 6, 5, 5}

sort.SliceStable(nums, func(i, j int) bool {
	return nums[i] < nums[j]
})
```

---

## Цикл For

Из-за стремления создателей Go к простоте обход коллекций осуществляется только через цикл for. 
Условное выражение пишется без скобок и тело цикла всегда должно быть внутри {}:
```go
nums := make([]int, 0, 10)

// начиная с 0; пока i меньше 10; инкрементим i после каждого шага
for i := 0; i < 10; i++ {
	nums = append(nums, i)
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7 ,8 ,9]
```

При необходимости for используется как цикл while в других языках:
```go
i := 0

nums := make([]int, 0, 10)

for i < 10 {
	nums = append(nums, i)
	i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если опустить условное выражение можно уйти в бесконечный цикл:
```go
i := 0

nums := make([]int, 0, 10)

for {
	if i == 10 {
		break
	}

	nums = append(nums, i)
	i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если условное выражение возвращает false или был вызван ==break== в теле, то происходит остановка цикла.
Перейти на следующую итерацию можно с помощью ключевого слова ==continue==:
```go
nums := make([]int, 0, 10)

// добавляем только четные числа в слайс
for i := 0; i < 10; i++ {
	if i % 2 != 0 {
		continue
	}

	nums = append(nums, i)
}

fmt.Println(nums) // [0 2 4 6 8]
```

Для обхода коллекции в Go есть "синтаксический сахар" ==range==. Эта конструкция обходит слайс, возвращая индекс и элемент на каждом шаге:
```go
names := []string{"John", "Harold", "Vince"}

// i - это индекс, name - это значение на текущем шаге цикла
for i, name := range names {
	fmt.Println("Hello ", name, " at index ", i)
}
```

---

## Map

Map - тип данных, предназначенный для хранения пар ключ-значение. В других языках эту структуру называют: ==хэш-таблица==,
словарь, ассоциативный массив. Запись и чтение элементов происходят в основном за O(1):
```go
// создание пустой мапы
var m map[int]string

// сокращенное создание пустой мапы
m := map[int]string{}

// рекомендуемое создание с обозначением размера
m := make(map[int]string, 10)

// создание мапы с элементами
m := map[int]string{1: "hello", 2: "world"}

// добавление элемента
m[3] = "!" // map[1:hello, 2:world, 3:!]

// чтение элемента
word := m[1] // "hello"

// len() возвращает количество записей (пар «ключ-значение») в карте
```

При чтении элемента по несуществующему ключу возвращается нулевое значение данного типа. Это приводит в ошибками логики, когда 
используется `bool` как значение. Для решения данной проблемы при чтении используется вторая переменная, в которую записывается наличие элемента в map:
```go
existedIDs := map[int64]bool{1: true, 2: true}

idExists, elementExists := existedIDs[2] // true, true

idExists, elementExists := existedIDs[225] // false, false
```

Элементы удаляются с помощью встроенной функции 
`delete(m map[Type]Type, key Type)`:
```go
engToRus := map[string]string{"hello":"привет", "world":"мир"}

delete(engToRus, "world")

fmt.Println(engToRus) // map[hello:привет]
```

Мапы в Go всегда передаются по ссылке:
```go
package main

import (
	"fmt"
)

func main() {
	m := map[int]string{1: "hello", 2: "world"}

	modifyMap(m)

	fmt.Println(m) // вывод: map[1:changed 2:world 200:added]
}

func modifyMap(m map[int]string) {
	m[200] = "added"

	m[1] = "changed"
}
```

### Обход map

Как слайс, map можно обойти с помощью конструкции for range:
```Go
idToName := map[int64]string{1: "Alex", 2: "Dan", 3: "George"}

//  первый аргумент - ключ, второй - значение

for id, name := range idToName {
	fmt.Println("id : ", id, "name: ", name)
}

Вывод:

id:  1 name:  Alex
id:  2 name:  Dan
id:  3 name:  George
```


Порядок ключей в map рандомизирован 


## Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

    type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
    }

Стоит отметить, что тип данных byte — это алиас к типу uint8 (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде. Во-вторых, 
байты представляют ASCII символы, а в кодовой таблице ASCII символов 256 кодов:

    package main

    import "fmt"

    func main() {
        s := "hey"

        fmt.Println(s[0], s[1], s[2]) // 104 101 121

        fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
    }

Большинство библиотечных функций работают со слайсами байт []byte для производительности. Конвертация строки в слайс байт описывается в коде явно:

    package main

    import "fmt"

    func main() {
        s := "hey"
        bs := []byte(s)

        fmt.Println([]byte(s)) // [104 101 121]

        fmt.Println(string(bs)) // hey
    }

Отдельные ASCII символы можно объявлять сразу с типом byte. Для этого нужно обернуть символ в одинарные кавычки и указать тип byte:

    package main

    import (
        "fmt"
        "reflect"
    )

    func main() {
        asciiCh := byte('Z')
        asciiChStr := string(asciiCh)

        fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

        fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Z
    }


## Обход строки

Так как строка - это массив байт, ее можно обойти с помощью цикла for:

    package main

    import (
        "fmt"
    )

    func main() {
        s := "hello"
        for i := 0; i < len(s); i++ {
            fmt.Println(string(s[i]))
        }
    }

Таким образом можно обойти только строки, состоящие из ASCII символов. Если строка содержит мультибайтовые символы, вывод будет некорректен.


## Руны

В современном мире невозможно работать только со строками, состоящими исключительно из ASCII символов. 
Везде используются нестандартные знаки, языки отличные от латиницы и эмодзи.
Для работы с такими Юникод символами в Go представлен тип данных rune:

    package main

    import (
        "fmt"
    )

    func main() {
        emoji := []rune("привет😀")

        for i := 0; i < len(emoji); i++ {
            fmt.Println(emoji[i], string(emoji[i])) // выводим код символа и его строковое представление
        }
    }

rune — это алиас к int32. Как и байты, руны были созданы для отличия от встроенного типа данных. 
Каждая руна представляет собой код символа стандарта Юникод. 
Строка свободно преобразуется в []byte и []rune, но эти 2 типа данных не конвертируются между собой напрямую

Строку можно преобразовать в срез unicode-символов (Go называет их рунами). Одна руна может занимать несколько байт (что и произошло с рунами г и о):

    runes := []rune(str)

    fmt.Println(runes)
    // [1075 1086 33]

    fmt.Println(str == string(runes))
    // true

В Go присутствует синтаксический сахар при обходе строки. 
Если использовать конструкцию for range, строка автоматически будет преобразована в []rune, то есть обход будет по Юникод символам:

    package main

    import (
        "fmt"
    )

    func main() {
        emoji := []rune("cool😀")

        for _, ch := range emoji {
            fmt.Println(ch, string(ch)) // выводим код символа и его строковое представление
        }
    }


## Стандартный пакет strings

Для работы со строками в Го существует стандартный пакет strings, который содержит основные функции.
Самые часто встречающиеся функции:

    import "strings"

    // проверяет наличие подстроки в строке
    strings.Contains("hello", "h") // true

    // разбивает строку по Юникод символам или по переданному разделителю
    strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

    // склеивает строки из слайса с разделителем
    strings.Join([]string{"hello", "world!"}, " ") // "hello world!"

Очень важная часть пакета это Builder. Когда необходимо собрать большую строку по каким-то правилам, 
использование конкатенации - не лучшее решение, потому что каждая операция создает новую строку, что сильно влияет на производительность
при большом объеме операций. Такая задача решается с помощью билдера:

    import "strings"

    sb := strings.Builder{}

    sb.WriteString("hello")
    sb.WriteString(" ")
    sb.WriteString("world")

    sb.String() // "hello world"


## Форматирование строк

Пакет fmt так же используется для форматирования строк.

    name := "Andry"

    // подставляем строку
    fmt.Sprintf("hello %s", name) // "hello Andry"

    // число
    fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

    // логический тип
    fmt.Sprintf("your story is %t", true) // "your story is true"


Так же существуют специальные плейсхолдеры, которые преобразуют сложные структуры:

    package main

    import (
        "fmt"
    )

    type Person struct {
        Name string
        Age int
    }

    func main() {
        p := Person{Name: "Andry", Age: 18}

        // вывод значений структуры
        fmt.Println("simple struct:", p)

        // вывод названий полей и их значений
        fmt.Printf("detailed struct: %+v\n", p)

        // вывод названий полей и их значений в виде инициализации
        fmt.Printf("Golang struct: %#v\n", p)
    }

Вывод:

    simple struct: {Andy 18}
    detailed struct: {Name:Andy Age:18}
    Golang struct: main.Person{Name:"Andy", Age:18}

[Документация](https://pkg.go.dev/fmt#hdr-Printing)


## Вариативные функции

Последний аргумент функции может быть вариативным. Функция может иметь максимум один вариативный аргумент и этот аргумент всегда слайс.
Чтобы обозначить аргумент вариативным, нужно поставить три точки …​ перед его типом:

    package main

    import (
        "fmt"
    )

    func main() {
        // кол-во аргументов может быть любым
        PrintNums(1, 2, 3)
    }


    func PrintNums(nums ...int) {
        for _, n := range nums {
            fmt.Println(n)
        }
    }

Также тремя точками можно разбить слайс на элементы при передаче в вариативную функцию. Например, встроенный метод append(slice []Type, elems …​Type) []Type, который добавляет последний элемент в слайс, принимает вариативный аргумент elems …​Type. Чтобы добавить один слайс в конец другого, нужно разбить второй слайс на элементы путем добавления трех точек …​ после переменной:

    nums1 := []int{1,2,3,4,5}

    nums2 := []int{6,7,8,9,10}

    res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]


## Указатели

Указатель (pointer) содержит адрес памяти, который ссылается на конкретное значение.
Тип *T — указатель на значение типа T. Если указатель не инициализирован, он равен nil (аналог None в питоне и null в js).

```go
// iptr - указатель на значение типа int
// пока что он пустой
var iptr *int
fmt.Println(iptr)
// <nil>
```


Оператор & возвращает указатель на конкретное значение:
```go
i := 42
iptr = &i

// теперь iptr ссылается на i
fmt.Println(iptr)
// 0xc000118000
```


0xc000118000 — адрес памяти. По этому адресу находится значение 42.

Оператор * обращается к значению, на которое ссылается указатель. Оно доступно как для чтения, так и для записи:
```go
// прочитать значение i через указатель iptr
fmt.Println(*iptr)
// 42

// установить значение i через указатель iptr
*iptr = 21
fmt.Println(i)
// 21

package main

import (
	"fmt"
)

type User struct {
	email    string
	password string
}

// при объявлении указываем,
// что переменная должна быть указателем.
// Для этого ставим звездочку * перед типом данных
func fillUserData(u *User, email string, pass string) {
	u.email = email
	u.password = pass
}

func main() {
	u := User{}

	// передаем указатель с помощью амперсанда
	// & перед переменной
	fillUserData(&u, "test@test.com", "qwerty")

	fmt.Printf("points on func call %+v\n", u)
	// points on func call {email:test@test.com password:qwerty}

	// сразу инициализируем переменную с указателем
	up := &User{}

	fillUserData(up, "test@test.com", "qwerty")

	fmt.Printf("points on init %+v\n", up)
	// points on init {email:test@test.com password:qwerty}
}

```

Мапы и срезы по умолчанию передаются с указателем:
```go
package main

import (
	"fmt"
)

func main() {
	m := map[string]int{}

	fillMap(m)

	fmt.Println(m) // map[random:1]
}

func fillMap(m map[string]int) {
	m["random"] = 1
}
```

Разработчики, пришедшие из других языков, часто используют фразы "передача по ссылке" или "ссылка на переменную". Строго говоря, в Go нет ссылок, только указатели:
```go
package main

import "fmt"

func main() {
	a := 1
	b := &a
	c := &b

	fmt.Printf("%p %p %p\n", &a, &b, &c)
	// 0xc000018030 0xc00000e028 0xc00000e030
}
```

В этом примере b и c содержат одинаковые значения — адрес переменной a, однако b и c хранятся в разных адресах. Из-за этого обновление переменной b не изменит c. Поэтому если кто-то говорит про ссылки в Go, он имеет в виду указатели.

[Ссылка на материалы](http://golang-book.ru/chapter-08-pointers.html)

## Интерфейсы

Интерфейс в Go — это набор сигнатур методов (то есть список методов без реализации).

Интерфейс геометрической фигуры:

    type geometry interface {
        area() float64
        perim() float64
    }

Реализуем интерфейс в типе «прямоугольник». Реализовать интерфейс = реализовать его методы. Действует «утиный» принцип, как в питоне: если у типа есть перечисленные в интерфейсе методы — значит, он реализовал интерфейс. Явно указывать, что rect реализует geometry, не требуется:

    type rect struct {
        width, height float64
    }

    func (r rect) area() float64 {
        return r.width * r.height
    }

    func (r rect) perim() float64 {
        return 2*r.width + 2*r.height
    }

Аналогично для типа «круг»:

    type circle struct {
        radius float64
    }

    func (c circle) area() float64 {
        return math.Pi * c.radius * c.radius
    }

    func (c circle) perim() float64 {
        return 2 * math.Pi * c.radius
    }

Если у переменной интерфейсный тип, она поддерживает все методы, заданные на интерфейсе. Благодаря этому функция measure() работает с любой фигурой, реализующей интерфейс geometry:

    func measure(g geometry) {
        fmt.Printf("%T: %+v\n", g, g)
        fmt.Println("area:", g.area())
        fmt.Println("perimiter:", g.perim())
    }

Раз типы circle и rect реализуют интерфейс geometry, мы можем передать их экземпляры в функцию measure():

    r := rect{width: 3, height: 4}
    c := circle{radius: 5}

    measure(r)
    // main.rect: {width:3 height:4}
    // area: 12
    // perimiter: 14

    measure(c)
    // main.circle: {radius:5}
    // area: 78.53981633974483
    // perimiter: 31.41592653589793