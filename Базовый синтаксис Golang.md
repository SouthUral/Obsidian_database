[[Golang]]

---

## Переменные

Go статически типизирован. Переменные объявляются явно, тип переменной заранее известен компилятору.
Существует два способа объявить переменную:

1) Длинная запись с ключевым словом var:
```go
var num int = 10
```
    
2) Короткая запись:
```go
num := 10
```

множественное объявление переменных:
```Go
v1, v2 := 3, 4
```
присваивание значения:
```Go
v1, v2 = 5, 6
```


Значение переменной можно изменять в любой момент, но в нее нельзя записать данные другого типа

Переменные принято называть в camelCase

Если не задавать значение переменной при инициализации она будет иметь нулевое значение:
```go
var (
	a string // ""
	b bool // false
	c int // 0
)
```


Переменные можно объявлять на уровне функций или пакетов
Именовать переменные нужно как можно короче (сокращать)

---

## Константы

Основное отличие от переменной, это то что константа далее в программе не изменяется.
Объявление константы:
```Go
const someConst = 15

const secondConst int = 20

const (
	constOne = "some"
	contTwo = "two"
)
```


---

## Типы данных

В Golang типы данных делятся на ==простые== и ==составные==.

### Простые типы данных
__Простые типы данных__ являются кирпичиками, простыми блоками. Простые типы включают в себя:
#### Строковый `string`

>[!Info] Строки в Golang - это неизменяемая последовательность байтов

Строки в Go объявляются с типом string:

```go

var s string = "text"
s := "text"
```

Практически всегда используются двойные кавычки. Однако они не подходят когда нужно написать несколько строк.
Для этого используют обратные кавычки:
```go

q := `
	SELECT *
	FROM person
	WHERE age > 18
`
```
 
Строки можно сравнивать операторами:

- == 
- > строка1 больше строки2 если строка2 меньше размером и является подстрокой строки1
- <
- <=
- >=

Базовые операции со строками это ==конкатенация== и ==интерполяция==:
```go

"hello " + "world" // "hello world"
```

В Go нет привычной интерполяции, как в динамических языках. Она реализуется через форматирующую функцию ==fmt.Sprintf()==:

```go

username := "Ivan"
greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

##### Длина строки
Узнать длину строки можно с помощью встроенной функции ==len()==:

```go
len("go") // 2
```

>[!info] Будьте внимательны!
> Функция len() считает кол-во байт, а не кол-во символов
 >   ```go
 >   len("го") // 4
 >   ```

Для подсчета количества символов, а не байтов, следует использовать конструкцию:
```Go

utf8.RuneCountInString("слово")

// результат будет 5
```

##### Поиск подстроки в строке
```Go
strings.Contains("строка в которой производится поиск", "подстрока")
```
`Contains()` Возвращает `true` либо `false`

#### Числовой тип  
Числовые типы состоят из:
- Целые :
	- Знаковые:
		- `int`
		- `int8`
		- `int16`
		- `int32`
		- `int64`
	- Беззнаковые unside int (хранят только положительные значения):
		- `uint`
		- `uint8`
		- `uint16`
		- `uint32`
		- `uint64`
	- С плавающей точкой:
		- `float32` точность 6 знаков после запятой, из-за недостатка точности могут копиться ошибки в программе
		- `float64` точность 15 знаков после запятой, лучше использовать этот тип
	- Комплексные числа (встречаются редко):
		 - `complex64`
		 - `complex128`
- Булев тип (логический) `bool`
	- Логические операторы которые работают с `bool` типом:
		- `!` логическое отрицание
		- `&&` логическое `и`
		- `||` логическое `или`

>[!info] В Golang `bool`тип автоматически не приводится к `int` типу

> [!info] У всех целочисленных числовых типов значение по умолчанию равно `0`

`type rune = int32` этот тип является unicode

`type byte = uint8` это байты

---


### Составные типы данных

####  Массивы

Массив - это коллекция однотипных значений фиксированной длины
```go
nums := [5]int{}
```

Если в литерале массива на месте длинны находится ==троеточие==, то длина массива определяется количеством инициализаторов.
```Go
q := [...]int{1, 2, 3}
```

Длина массива указывается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:
```go
nums := [5]int{} // [0, 0, 0, 0, 0]

var nums [5]int // [0, 0, 0, 0, 0]
```

>[!info] Размер массива должен быть константным выражением!
>Т.е. выражением, значение которого может быть вычеслено во время компиляции программы.

>[!info] Если тип элемента массива является сравниваемым, то  таким же является и тип массива

При попытке инициализации элементов за границей массива выходит ошибка компиляции:
```go
nums := [1]int{1, 2} // array index 1 out of bounds [0:1]
```

Чтение и запись элементов массива происходит через квадратные скобки:
```go
nums := [3]int{1, 2, 3}

fmt.Println(nums[1]) // 2

nums[2] = 33

fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0. При попытке чтения/записи элементов за границей массива выходит ошибка компиляции:
```go
words := [2]string{}

words[2] // invalid array index 2 (out of bounds for 2-element array)
```

Массивы в Go передаются по значению, следовательно, любое изменение внутри функции не влияет на исходный массив. ==Это означает, что в функцию передается копия массива==:
```go
package main 

import (
	"fmt"
)

func main() {
	a := [3]int{1, 2, 3}

	midifyArr(a)

	fmt.Println(a) // 1, 2, 3
}

func modifyArr(nums [3]int) {
	nums[0] = 35
}
```



В Go есть встроенная функция len(), которая возвращает длину массива:
```go
fmt.Println(len([5]int{1, 2, 3})) // 5
fmt.Println(len([10]int{})) // 10
```

Массивы одноразмерны, но их можно комбинировать, чтобы получить нужную размерность:
```go
var arr [2][3]int

for i := 0; i < 2; i++ {
	fot j := 0; j < 3; j++ {
		arr[i][j] = i + j
	}
}

fmt.Println("2d:", arr) // 2d: [[0, 1, 2][1, 2, 3]]
```



#### Слайсы
![[Слайсы golang]]
#### Map
![[Map (словарь) golang]]



## Функции

Функции в Go объявляют через ключевое слово func:
```go
func miltiply(x int, y int) int {
	return x * y
}
```

Тип аргументов пишется после названия переменной
Если несколько аргументов подряд имеют один и тот же тип то можно написать сокращенно:
```go
func multiply(x, y int) int {

}
```
   
После скобок с аргументами пишется тип возвращаемого значения

Если функция именованна с заглавной буквы то эта функция доступна вне пакета (она экспортируется, те. публичная),
если начинается со строчной то это функция используется только локально в рамках пакета:
```go
package math

// можно вызвать извне как math.Multiply(4, 5)
func Multiply(x, y int) int {
	return x * y
}

// приватная функция, извне не вызвать
func devide(x, y int) int {

}
```

Из одной функции можно возвращать несколько значений, чаще всего используется для ошибок:
```go
package math

import "errors"

func divide(x, y int) (int, error) {
	if y == 0 {
		return 0, errors.New("cannot divide on zero")
	}

	return x / y, nil
}
```

Возвращаемые значения могут быть именованными:
```go
func multiply(x, y int) (res int) {
	res = x * y
	return 
}
```

Использовать именованные возвращаемые аргументы плохая практика
	1) увеличивается сложность чтения кода;
	2) переменная может быть несколько раз определена в теле функции, что может привести к неожиданному поведению;
	3) пустой return неявно возвращает аргументы.

### Анонимные функции

Go поддерживает анонимные функции. Работают они как обычные, но не имеют названия (как лямбды в питоне или стрелочные функции в js).

Чаще всего анонимные функции используют, чтобы вернуть из функции другую функцию. В примере ниже intSeq() возвращает функцию-генератор, которая при каждом вызове выдает очередное значение счетчика i. Генератор использует переменную, определенную во внешней функции — то есть образует замыкание (closure):
```go
func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}
```

Результат вызова intSeq() — функцию-генератор — мы записываем в переменную next. У next собственное значение счетчика i, которое увеличивается при каждом вызове:
```go
next := intSeq()

fmt.Println(next())
// 1
fmt.Println(next())
// 2
fmt.Println(next())
// 3
```

Если создать еще один генератор — он будет обладать собственным счетчиком i:
```go
gen := intSeq()
fmt.Println(gen())
// 1
fmt.Println(gen())
// 2
```

Иногда анонимную функцию передают как аргумент другой функции. Пример из пакета sort :
```go
func Search(n int, f func(int) bool) int
```

Search() находит наименьшее i из диапазона [0, n), для которого функция-предикат f(i) вернет true. В качестве предиката удобно использовать анонимную функцию:

```go
a := []int{1, 2, 4, 8, 16, 32, 64, 128}
x := 53

// ближайший сверху к `x` элемент среза `a`
closest := sort.Search(len(a), func(i int) bool { return a[i] >= x })

fmt.Println(a[closest], "is the closest to", x)
// 64 is the closest to 53
```
---

## Числа и операции над ними

>[!info] В Go представлено много числовых типов данных: 
>
	- uint,
	- uint8,
	- uint16,
	- uint32,
	- uint64,
	- int,
	- int8,
	- int16,
	- int32,
	- int64,
	- float32,
	- float64,
	- complex64,
	- complex128

В ежедневной работе используются только:

- ==int== - основной кроссплатформенный тип целых чисел, может быть отрицательным;

- ==int64==  нужен для больших чисел  из внешних систем. Например, ID в СУБД имеет тип bigint.
    чтобы правильно распарсить такой ID используется int64;

- ==float64== число с плавающей точкой. Чаще всего используется для математических операций
    например функция math.Max(), определяющая наибольшее число, принимает аргументы в виде float64;

### Арифметические операции

В GO имеется стандартный набор арифметических операций:
```go

x := 10
y := 5

x + y // 15

x - y // 5

x / y // 2

x * y // 50
```

Любые операции осуществляются только над числами одинакового типа:
```Go

x := 5.05
y := 10

x + y  // invalid operation: x + y (mismatched types float64 and int)
```

Чтобы осуществить такое сложение нужно сконвертировать значения к одному типу:
```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

При приведении к одному типу есть ряд ньюансов:
```go

// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```
---

## Логические типы

Логический тип в Go представлен привычными значениями true и false c операторами:

- && (and)

- == (равно)

- || (или)

- ! (не)

Объявление переменных происходит через ключевое слово bool:
```go

var b bool = true
bs := false
```


>[!info] Из-за строгой типизации в Go можно сравнивать только одинаковые типы данных:
>```go
>
>true == false // false
>false == false // true
>```
>Т.е. нельзя сравнить пустую строку с false
Пример проверки строки на пустую:
>```go
flag := true
text := "hello"
>flag && text != "" // true


---

## Операторы управления потоком

### Условные конструкции

Условия в Go представлены обычным блоком if else. В условии должно быть строго выражение логического типа.
Пример:
```go

package main

import (
	"fmt"
	"strings"
)

func statusByName(name string) string {
	// функция проверяет, что строка name начинается с подстроки "Mr."
	if strings.HasPrefix(name, "Mr.") {
		return "married man"
	} else if strings.HasPrefix(name, "Mrs.") {
		return "married woman"
	} else {
		return "single person"
	}
}

func main() {
	n := "Mr. Doe"
	fmt.Println(n + " is a " + statusByName(n)) // Mr. Doe is a married man

	n = "Mrs. Berry"
	fmt.Println(n + " is a " + statusByName(n)) // Mrs. Berry is a married woman

	n = "Karl"
	fmt.Println(n + " is a " + statusByName(n)) // Karl is a single person
}
```
---

### Switch
В Go есть альтернатива if - конструкция switch. Когда срабатывает условие какого-либо case, программа
выполняет блок и выходит из конструкции switch без необходимости писать break:
```go

x := 10

switch x {
	default: // default всегда выполняется последним независимо от расположения и конструкции
		fmt.Println("default case")
	case 10:
		fmt.Println("case 10")
}
```

Однако при необходимости можно реализовать логику С-подобных языков и провалится в следующий case:

```go
switch { // выражение отсутствует. Для компилятора выглядит как: switch true
	default:
		fmt.Println("default case")
	case x == 10:
		fmt.Println("equal 10 case")
		fallthrough // игнорирует условние и сразу выполняет тело
	case x <= 10:
		fmt.Println("less or equal 10 case")
}
```
Output:
```go
equal 10 case
less or equal 10 case
```

Еще один пример Case:

Напишите программу, которая определяет название языка по его коду. Правила:

en → English
fr → French
ru или rus → Russian
иначе → Unknown

```go

package main

import (
	"fmt"
)

func main() {
	var code string
	fmt.Scan(&code)

	// определите полное название языка по его коду
	// и запишите его в переменную `lang`
	// ...
	var lang string

	switch code {
	case "en":
		lang = "English"
	case "fr":
		lang = "French"
	case "ru", "rus":
		lang = "Russian"
	default:
		lang = "Unknown"
	}
	
	fmt.Println(lang)
}
```
---

### Defer

Оператор **defer** откладывает выполнение функции до того момента, как произойдет возврат из окружающей функции.

Аргументы отложенных вызовов вычисляются сразу же, но вызов функции не происходит до того, как произойдет возврат из окружающей функции.

```go
package main

import "fmt"

func main() {
    defer fmt.Println("world")

    fmt.Println("hello")
}

//hello
//world
```

#### Накопление отложенных вызовов

Отложенные вызовы функций сохраняются в стеке. Когда происходит возврат из функции, ее отложенные вызовы выполняются в порядке "последним-пришел-первым-вышел" ==(LIFO, last-in-first-out)==.
```go
package main

import "fmt"

func main() {
    fmt.Println("Подсчет...")

    for i := 0; i < 10; i++ {
        defer fmt.Println(i)
    }

    fmt.Println("выполнен")
}
```
Вывод:
```bash
Подсчет...
выполнен
9
8
7
6
5
4
3
2
1
0
```

---

## Структуры

В Go нет классов и привычной реализации ООП. Вместо классов в языке используются структуры -
наборы полей, имеющих название и тип данных. Объявление структуры:
```Go
type Person struct {
	// [название поля] [тип данных]
	Name string
	Age int
}

func main() {
	p := Person{Name: "John", Age: 25}

	p.Name // "John"
	p.Age // 25
}
```

Структуру можно инициализировать не передавая значения. В этом случае каждое поле примет свое нулевое значение

Регистр первой буквы в названии структуры и полей означает публичность, точно так же, как в переменных и функциях. Если первая буква заглавная,
то структуру можно инициализировать во внешних пакетах. Иначе она доступна только в пределах текущего пакета.

```Go
type Person struct { // структура публична
    Name string // поле публично
    wallet wallet // поле приватно: можно обращаться только внутри текущего пакета
    }

type wallet struct { // структура приватна: можно инициализировать только внутри текущего пакета
    id string
    moneyAmount float64
    }
```


У любого поля структуры можно указать теги. Они используются для метаинформации о поле для сериализации,  
валидации, маппинга данных из БД и т.д. Тег указывается после типа данных через бектики:

```go

type User struct {
	ID int64 `json:"id" validate:"required"`
	Email string `json:"email" validate:"required,email"`
	FirstName string `json:"first_name" validate:"required"`
}
```


Тег json используется для названий полей при сериализации/десериализации структуры в json и обратно:
```go

package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	ID        int64  `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
}

func main() {
	u := User{}
	u.ID = 22
	u.Email = "test@test.com"
	u.FirstName = "John"

	bs, _ := json.Marshal(u)

	fmt.Println(string(bs)) // {"id":22,"email":"test@test.com","first_name":"John"}
}
```

>[!info] json.Marshal()
>функция `json.Marshal()` преобразует структуру в json


Тег validate используется Go-валидатором. Пример вызова функции структур:

```go

package main

import (
	"fmt"
	"github.com/go-playground/validator/v10"
)

type User struct {
	ID        int64  `validate:"required"`
	Email     string `validate:"required,email"`
	FirstName string `validate:"required"`
}

func main() {
	// создали пустую структуру, чтобы проверить валидацию
	u := User{}

	// создаем валидатор
	v := validator.New()

	// метод Struct валидирует переданную структуру и возвращает ошибку `error`, если какое-то поле некорректно
	fmt.Println(v.Struct(u))
}
```
### Анонимные структуры
Можно объявить, что переменная реализует структурный тип без предварительного присвоения имени этому структурному типу. Такие структуры называются _анонимными_. 
```go
var person struct {
	name string
	age  int
	pet  string
}

person.name = "bob"
person.age = 23
person.pet = "dog"

pet := struct {
	name string
	kind string
}{
	name: "Fido",
	kind: "dog",
} 
```
__Анонимные структуры__ удобно использовать в двух случаях:
 - Преобразование данных в структуру (_демаршаллинг_) или наоборот, структуру во внешние данные (_маршаллинг_);
 - Применение табличных тестов.

### Композиция

В Go нет наследования. Вместо него активно используется композиция — когда новое поведение собирают из кирпичиков существующего.

Есть тип «счетчик»:
```go
type counter struct {
	value uint
}
```

Его можно увеличивать на единицу:
```go
func (c *counter) increment() {
	c.value++
}
```


Или на указанное число:
```go
func (c *counter) incrementDelta(delta uint) {
	c.value += delta
}
```

Мы хотим замерять использование сервисов. Чтобы не дублировать существующие функции, добавим счетчик в тип «использование сервиса»:
```go
    type usage struct {
        service string
        counter counter
    }

    func makeUsage(service string) usage {
        return usage{service, counter{}}
    }
```

Будем мерить использование сервиса, увеличивая его счетчик:
```go
usage := makeUsage("find")
usage.counter.increment()
usage.counter.increment()
usage.counter.increment()
fmt.Printf("%s usage: %d\n", usage.service, usage.counter.value)
// find usage: 3
```

Для типа «просмотры страницы» тоже добавим счетчик:
```go
type pageviews struct {
	url *url.URL
	counter counter
}

func makePageviews(uri string) pageviews {
	u, err := url.Parse(uri)
	if err != nil {
		log.Fatal(err)
	}
	return pageviews{u, counter{}}
}
```

И будем мерить просмотры:
```go
pv := makePageviews("/doc/find")
pv.counter.incrementDelta(100)
fmt.Printf("%s views: %d\n", pv.url, pv.counter.value)
// /doc/find views: 100
```

### Встраивание

Все хорошо, но несколько неудобно было писать usage.counter.increment() на предыдущем шаге. По-хорошему, usage  расширяет counter — отношение между ними больше похоже на наследование, чем на композицию. В Go в таких случаях используют встраивание (embedding). Посмотрим, как оно работает.

Есть тип «счетчик», такой же, как на предыдущем шаге:
```go
type counter struct {
	value uint
}
func (c *counter) increment() {
	c.value++
}
func (c *counter) incrementDelta(delta uint) {
	c.value += delta
}
```

Мы хотим замерять использование сервисов. Встроим счетчик в тип «использование сервиса»:
```go
type usage struct {
	service string
	counter
}

func makeUsage(service string) usage {
	return usage{service, counter{}}
}
```

Благодаря встраиванию, поля и методы счетчика доступны прямо на usage, без обращения к полю counter:
```go
usage := makeUsage("find")
usage.increment()
usage.increment()
usage.increment()
fmt.Printf("%s usage: %d\n", usage.service, usage.value)
// find usage: 3
```

Аналогично с типом «просмотры страниц»:
```go
type pageviews struct {
	url *url.URL
	counter
}

func makePageviews(uri string) pageviews {
	u, err := url.Parse(uri)
	if err != nil {
		log.Fatal(err)
	}
	return pageviews{u, counter{}}
}
```

Поля и методы счетчика доступны прямо на pageviews:
```go
pv := makePageviews("/doc/find")
pv.incrementDelta(100)
fmt.Printf("%s views: %d\n", pv.url, pv.value)
// /doc/find views: 100
```
---

## Константы

Константы - это постоянные значения, которые инициализируются один раз и не изменяются в течении всего выполнения программы.
Объявление константы:
```go
const [название] [тип данных] = [значение]

const StatusOk int = 200
```

На практике тип данных не указывается, и несколько констант принято объявлять в рамках одного const:
```go
const (
	StatusOk = 200
	StatusNotFound = 404
)
```

>[!info] Только некоторые типы данных можно присвоить константе:  
> -  строки,
> - числа,
> - символы,
> - логический тип.
Регистр первой буквы указывает на публичность/приватность константы.
Константы можно объявлять на уровне функций, либо пакета.

Для последовательных числовых констант следует использовать индентификатор iota, который присвоит для списка чисел значения от 0:
```go
package main

import "fmt"

const (
	zero = iota
	one
	two
	three
)

func main() {
	fmt.Println(zero, one, two, three) // 0 1 2 3
}
```

---

## Цикл For

Из-за стремления создателей Go к простоте обход коллекций осуществляется только через цикл for. 
Условное выражение пишется без скобок и тело цикла всегда должно быть внутри {}:
```go
nums := make([]int, 0, 10)

// начиная с 0; пока i меньше 10; инкрементим i после каждого шага
for i := 0; i < 10; i++ {
	nums = append(nums, i)
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7 ,8 ,9]
```

При необходимости for используется как цикл while в других языках:
```go
i := 0

nums := make([]int, 0, 10)

for i < 10 {
	nums = append(nums, i)
	i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если опустить условное выражение можно уйти в бесконечный цикл:
```go
i := 0

nums := make([]int, 0, 10)

for {
	if i == 10 {
		break
	}

	nums = append(nums, i)
	i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если условное выражение возвращает false или был вызван ==break== в теле, то происходит остановка цикла.
Перейти на следующую итерацию можно с помощью ключевого слова ==continue==:
```go
nums := make([]int, 0, 10)

// добавляем только четные числа в слайс
for i := 0; i < 10; i++ {
	if i % 2 != 0 {
		continue
	}

	nums = append(nums, i)
}

fmt.Println(nums) // [0 2 4 6 8]
```

Для обхода коллекции в Go есть "синтаксический сахар" ==range==. Эта конструкция обходит слайс, возвращая индекс и элемент на каждом шаге:
```go
names := []string{"John", "Harold", "Vince"}

// i - это индекс, name - это значение на текущем шаге цикла
for i, name := range names {
	fmt.Println("Hello ", name, " at index ", i)
}
```

---




## Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

    type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
    }

Стоит отметить, что тип данных byte — это алиас к типу uint8 (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде. Во-вторых, 
байты представляют ASCII символы, а в кодовой таблице ASCII символов 256 кодов:

    package main

    import "fmt"

    func main() {
        s := "hey"

        fmt.Println(s[0], s[1], s[2]) // 104 101 121

        fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
    }

Большинство библиотечных функций работают со слайсами байт []byte для производительности. Конвертация строки в слайс байт описывается в коде явно:

    package main

    import "fmt"

    func main() {
        s := "hey"
        bs := []byte(s)

        fmt.Println([]byte(s)) // [104 101 121]

        fmt.Println(string(bs)) // hey
    }

Отдельные ASCII символы можно объявлять сразу с типом byte. Для этого нужно обернуть символ в одинарные кавычки и указать тип byte:

    package main

    import (
        "fmt"
        "reflect"
    )

    func main() {
        asciiCh := byte('Z')
        asciiChStr := string(asciiCh)

        fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

        fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Z
    }


## Обход строки

Так как строка - это массив байт, ее можно обойти с помощью цикла for:

    package main

    import (
        "fmt"
    )

    func main() {
        s := "hello"
        for i := 0; i < len(s); i++ {
            fmt.Println(string(s[i]))
        }
    }

Таким образом можно обойти только строки, состоящие из ASCII символов. Если строка содержит мультибайтовые символы, вывод будет некорректен.


## Руны

В современном мире невозможно работать только со строками, состоящими исключительно из ASCII символов. 
Везде используются нестандартные знаки, языки отличные от латиницы и эмодзи.
Для работы с такими Юникод символами в Go представлен тип данных rune:

    package main

    import (
        "fmt"
    )

    func main() {
        emoji := []rune("привет😀")

        for i := 0; i < len(emoji); i++ {
            fmt.Println(emoji[i], string(emoji[i])) // выводим код символа и его строковое представление
        }
    }

rune — это алиас к int32. Как и байты, руны были созданы для отличия от встроенного типа данных. 
Каждая руна представляет собой код символа стандарта Юникод. 
Строка свободно преобразуется в []byte и []rune, но эти 2 типа данных не конвертируются между собой напрямую

Строку можно преобразовать в срез unicode-символов (Go называет их рунами). Одна руна может занимать несколько байт (что и произошло с рунами г и о):

    runes := []rune(str)

    fmt.Println(runes)
    // [1075 1086 33]

    fmt.Println(str == string(runes))
    // true

В Go присутствует синтаксический сахар при обходе строки. 
Если использовать конструкцию for range, строка автоматически будет преобразована в []rune, то есть обход будет по Юникод символам:

    package main

    import (
        "fmt"
    )

    func main() {
        emoji := []rune("cool😀")

        for _, ch := range emoji {
            fmt.Println(ch, string(ch)) // выводим код символа и его строковое представление
        }
    }


## Стандартный пакет strings

Для работы со строками в Го существует стандартный пакет strings, который содержит основные функции.
Самые часто встречающиеся функции:

    import "strings"

    // проверяет наличие подстроки в строке
    strings.Contains("hello", "h") // true

    // разбивает строку по Юникод символам или по переданному разделителю
    strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

    // склеивает строки из слайса с разделителем
    strings.Join([]string{"hello", "world!"}, " ") // "hello world!"

Очень важная часть пакета это Builder. Когда необходимо собрать большую строку по каким-то правилам, 
использование конкатенации - не лучшее решение, потому что каждая операция создает новую строку, что сильно влияет на производительность
при большом объеме операций. Такая задача решается с помощью билдера:

    import "strings"

    sb := strings.Builder{}

    sb.WriteString("hello")
    sb.WriteString(" ")
    sb.WriteString("world")

    sb.String() // "hello world"


## Форматирование строк

Пакет fmt так же используется для форматирования строк.

    name := "Andry"

    // подставляем строку
    fmt.Sprintf("hello %s", name) // "hello Andry"

    // число
    fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

    // логический тип
    fmt.Sprintf("your story is %t", true) // "your story is true"


Так же существуют специальные плейсхолдеры, которые преобразуют сложные структуры:

    package main

    import (
        "fmt"
    )

    type Person struct {
        Name string
        Age int
    }

    func main() {
        p := Person{Name: "Andry", Age: 18}

        // вывод значений структуры
        fmt.Println("simple struct:", p)

        // вывод названий полей и их значений
        fmt.Printf("detailed struct: %+v\n", p)

        // вывод названий полей и их значений в виде инициализации
        fmt.Printf("Golang struct: %#v\n", p)
    }

Вывод:

    simple struct: {Andy 18}
    detailed struct: {Name:Andy Age:18}
    Golang struct: main.Person{Name:"Andy", Age:18}

[Документация](https://pkg.go.dev/fmt#hdr-Printing)


## Вариативные функции

Последний аргумент функции может быть вариативным. Функция может иметь максимум один вариативный аргумент и этот аргумент всегда слайс.
Чтобы обозначить аргумент вариативным, нужно поставить три точки …​ перед его типом:
```go
package main

import (
	"fmt"
)

func main() {
	// кол-во аргументов может быть любым
	PrintNums(1, 2, 3)
}


func PrintNums(nums ...int) {
	for _, n := range nums {
		fmt.Println(n)
	}
}
```


Также тремя точками можно разбить слайс на элементы при передаче в вариативную функцию. Например, встроенный метод append(slice []Type, elems …​Type) []Type, который добавляет последний элемент в слайс, принимает вариативный аргумент elems …​Type. Чтобы добавить один слайс в конец другого, нужно разбить второй слайс на элементы путем добавления трех точек …​ после переменной:
```go
nums1 := []int{1,2,3,4,5}

nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]
```


## Указатели

Указатель (pointer) содержит адрес памяти, который ссылается на конкретное значение.
Тип *T — указатель на значение типа T. Если указатель не инициализирован, он равен nil (аналог None в питоне и null в js).

```go
// iptr - указатель на значение типа int
// пока что он пустой
var iptr *int
fmt.Println(iptr)
// <nil>
```


Оператор & возвращает указатель на конкретное значение:
```go
i := 42
iptr = &i

// теперь iptr ссылается на i
fmt.Println(iptr)
// 0xc000118000
```


0xc000118000 — адрес памяти. По этому адресу находится значение 42.

Оператор * обращается к значению, на которое ссылается указатель. Оно доступно как для чтения, так и для записи:
```go
// прочитать значение i через указатель iptr
fmt.Println(*iptr)
// 42

// установить значение i через указатель iptr
*iptr = 21
fmt.Println(i)
// 21

package main

import (
	"fmt"
)

type User struct {
	email    string
	password string
}

// при объявлении указываем,
// что переменная должна быть указателем.
// Для этого ставим звездочку * перед типом данных
func fillUserData(u *User, email string, pass string) {
	u.email = email
	u.password = pass
}

func main() {
	u := User{}

	// передаем указатель с помощью амперсанда
	// & перед переменной
	fillUserData(&u, "test@test.com", "qwerty")

	fmt.Printf("points on func call %+v\n", u)
	// points on func call {email:test@test.com password:qwerty}

	// сразу инициализируем переменную с указателем
	up := &User{}

	fillUserData(up, "test@test.com", "qwerty")

	fmt.Printf("points on init %+v\n", up)
	// points on init {email:test@test.com password:qwerty}
}

```

Мапы и срезы по умолчанию передаются с указателем:
```go
package main

import (
	"fmt"
)

func main() {
	m := map[string]int{}

	fillMap(m)

	fmt.Println(m) // map[random:1]
}

func fillMap(m map[string]int) {
	m["random"] = 1
}
```

Разработчики, пришедшие из других языков, часто используют фразы "передача по ссылке" или "ссылка на переменную". Строго говоря, в Go нет ссылок, только указатели:
```go
package main

import "fmt"

func main() {
	a := 1
	b := &a
	c := &b

	fmt.Printf("%p %p %p\n", &a, &b, &c)
	// 0xc000018030 0xc00000e028 0xc00000e030
}
```

В этом примере b и c содержат одинаковые значения — адрес переменной a, однако b и c хранятся в разных адресах. Из-за этого обновление переменной b не изменит c. Поэтому если кто-то говорит про ссылки в Go, он имеет в виду указатели.

[Ссылка на материалы](http://golang-book.ru/chapter-08-pointers.html)

## Интерфейсы

![[Интерфейсы golang]]