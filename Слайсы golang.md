
[видео о слайсах №1](https://www.youtube.com/watch?v=10LW7NROfOQ&t=1442s)
[видео о слайсах №2](https://www.youtube.com/watch?v=1vAIvqDo5LE&t=6s)

>[!info] Срез (slice)
>Срез - ключевая структура данных в Go. Это массив изменяемой длины, как list в питоне или Array в js. Обычно в программах на Go оперируют именно срезами, «чистые» массивы встречаются намного реже.

==Слайс - это массив неопределенной длинны (или динамический массив)==
```go
var nums = []int{1, 2, 3}

nums := []int{1, 2, 3}
```

Чтение и запись осуществляется так же как и в массивах:
```go
nums := []int{1, 2, 3}

nums[2] // 3

nums[0] = 10 // [10, 2, 3]

// с помощью оператора : можно получить элементы от нижней до верхней границы

nums[1:3] // [2, 3]

nums[:2] // [10, 2]

nums[2:] // 3
```


В слайсы можно добавлять элементы с помощью встроенной функции func append(slice []Type, elems ...Type) []Type,
которая возвращает новый слайс с добавленным элементом:
```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

>[!info] 
>Срез (слайс) - это структура данных, которая содержит три значения:
>- указатель на массив;
>- емкость среза `cap`;
>- длину среза `len`;
>`cap` и `len` используются для создания массива

Длина среза - это количество значений, которые он может содержать в данный момент.
Емкость среза - это количество элементов, которые могут быть сохранены в базовом массиве, прежде чем размер среза должен быть изменен и создан новый массив.

Инициализация среза нужной длинны с помощью функции:
```go
func make(t Type, len, cap IntegerType) Type. 
```

==Для начала рекомендуется использовать make везде, где можно:==
```go
// len = 5 Массив будет сразу заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5, массив будет пустым, однако заполнение слайса через append будет эффективным
// потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса как аргумента функции происходит хитро. Длина и вместимость передаются по значению, но 
массив значений передается по ссылке. Вследствие этого получается неявное поведение: добавленные элементы не сохранятся 
в исходный слайс, но изменения существующих останется:
```go
package main

import (
	"fmt"
)

func main() {
	nums := []int{1, 2, 3, 4, 5}

	modifySlice(nums)

	fmt.Println(nums)
}

func modifySlice(nums []int) {
	nums[2] = 10 // элемент будет и в исходном слайсе

	nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Для того чтобы сделать слайс слайсов:
```go
a := make([][]int, 0)
```

Но в таком случае вложенные слайсы так же должны иметь такой же тип данных []int

##### Полезные советы при работе со слайсами

>[!info] Проверять слайс на пустоту с помощью `len(list) == 0` 

>[!info] Если известен итоговый размер слайса, то нужно всегда алоцировать под него память.
>Т.е. если известно что слайс будет из 5 элементов то можно сделать так
>```go
>list := make([]int, 0, 5)
>```

>[!info] Если нужно изменить переданный в функцию слайс, но при этом нужно не изменить внешний слайс, то перед изменением нужно сначала создать копию переданного слайса.
>```go
>func main() {
>	list := []int{1, 2, 3, 4}
>	newList := handle(list)
>}
>
>func handle(list []int) []int {
>	newList := make([]int, len(list))
>	copy(newList, list)
>	newList := append(newList, 5)
>	return newList
>}
>```

>[!info] Результат работы функции `append()` нужно присваивать той же самой переменной.



---

##### Копирование слайсов

В языке есть встроенная функция `func copy(dst, src []Type) int`, которая копирует слайс src в слайс dst и возвращает количество
скопированных элементов:
```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

Почему мы не можем просто перезаписать слайс в другую переменную и изменять ее? Как и с функциями, при присваивании слайса к переменной, 
копируется только длина и вместимость, но массив передается по ссылке:
```go
nums := []int{1,2,3,4,5}

numsCp := nums

// исходный слайс nums тоже будет изменен
numsCp[0] = 10

fmt.Println(nums) // [10,2,3,4,5]
```

Существует распространенная ошибка, когда пытаются скопировать слайсы различной длины. 
В этом случае элементы, выходящие за рамки слайса dst, не будут скопированы:
```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

---

##### Сортировка слайсов

В го существует готовое решение для сортировки массива. Стандартный пакет sort предоставляет функции для сортировки:
```go
Slice(x interface{}, less func(i, j int) bool)

nums := []int{2, 1, 6, 5, 3, 4}

sort.Slice(nums, func(i, j int) bool {
	return nums[i] < nums[j]
})
```

>[!info] Пустой интерфейс
>Пустой интерфейс в Го означает тип данных, под который подходит любой другой тип

В функцию `Slice(x interface{}, less func(i, j int) bool)` передается слайс любого типа данный, как первый аргумент.
Вторым аргументом передается функция, которая берет элементы по индексу `i` и определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`

Под капотом в функции sort.Slice используется быстрая сортировка. В пакете также присутствует сортировка вставками sort.SliceStable:
```go
nums := []int{2, 3, 1, 6, 5, 5}

sort.SliceStable(nums, func(i, j int) bool {
	return nums[i] < nums[j]
})
```
