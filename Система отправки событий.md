[[Проекты]]

### Задача
Нужна событийная система, сервисы должны отправлять событие, другие сервисы могут эти события перехватывать для своей логики. Так же нужна система для хранения событий

### Основные компоненты
- Сервис сохранения всех сообщений;
	- сервис создает Exchange (1 или 2)
	- этот сервис имеет свою БД и записывает туда все события;
	- в теории он может выдать эти события обратно в событийную систему;
- Rabbit c exchange;
- Отправители (отправляют сообщения `события` в RabbitMQ);
- Получатели (получают сообщения из RabbitMQ)

### Этапы решения задачи
1. [ ] Реализовать менеджера получателей. В менеджер получателей приходят события от обработчиков gRPC с несколькими типами сообщений. Нужно сделать реакцию на каждый тип сообщения.
	1. [ ] Тип сообщения ==новая подписка==:
		1. [ ] Поиск __внутреннего получателя__ по переданной конфигурации.
			1. [ ] Если получатель найден:
				 - [ ] вызов метода для добавления нового внешнего потребителя внутреннему получателю.
			2.  [ ] Если получатель не найден:
				 - [ ] инициализация получателя,
				 - [ ]  вызов метода для добавления нового внешнего потребителя внутреннему получателю.
	2.  [ ] Тип сообщения ==остановка подписчика== возникает когда внешний подписчик отваливается или заканчивается время ожидания у обработчика gRPC:
		1. [ ] Поиск по конфигу нужного отправителя и вызов у него метода остановки промежуточного подписчика (нужно передать имя подписчика)
	3. [ ] В начале работы менеджер получателей должен запросить состояние у модуля работы с состоянием.
		1. Передается запрос в модуль состояния.
		2. В модуле состояние делается запрос через модуль БД к самой БД
			1. Если данные есть:
				1. данные возвращаются по каналу в менеджер получателей (менеджер получателей должен ждать ответа)
				2. менеджер получателей создает по полученным данным внутренние очереди (внутренних потребителей) инициализируя их.
					1. в функцию инициализации передается список подписчиков (подписчики будут добавлены в список спящих потребителей, т.е. просто создана структура с именем и оффсетом)
			2. Если данных нет:
				1. менеджер получателей просто переходит в режим ожидания событий от API
1. Реализация внутреннего получателя:
	-  Внутреннему получателю нужны списки (словари) активных подписчиков и спящих подписчиков. 
	-  Метод остановки внутреннего подписчика `sleepConsumer` вызывает метод остановки всех процессов у промежуточного подписчика и перемещает его из списка активных подписчиков в список спящих.
2.  Нужен механизм сохранения состояния. Это должен быть отдельный модуль который подключается к БД и по запросу от модулей, которым нужно сохранять свое состояние, отправлять состояние в БД. У модуля должен быть метод для восстановления состояния системы. Он должен запускаться сразу после запуска сервиса.
	1. В состоянии нужно хранить всех внутренних подписчиков с их конфигом. 
	2. Нужно хранить всех промежуточных подписчиков (имя подписчика, offset последнего не переданного события)
	3. Сохранение состояния должно быть асинхронным, т.е. каждый элемент, которому нужно свое состояние должен сам его сохранять, т.к. есть элементы у которых состояние меняется постоянно, и есть элементы у которых состояние меняется редко.
	4. Нужен метод для восстановления состояния сервиса, он должен быть запущен сразу после запуска сервиса.
Пример структуры
```json
[
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_1": "last_offset",
			"consumer_2": "last_offset",
		},
	},
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_5": "last_offset",
			"consumer_6": "last_offset",
		},
	},
]

```
4. [ ] Нужен механизм сохранения событий, которые попадают во внутренний получатель, в БД:
	1. Нужно определиться со структурой БД. Надо понять, создавать ли для каждой очереди свою таблицу, или записывать все очереди в одну таблицу разделенную по партициям;
	2. Нужен механизм записи события очереди в БД
5. [ ] Нужен механизм восстановления очереди, при переподключении внешнего потребителя (т.е. перевод промежуточного потребителя из спящего состояния в активное)
	1. Механизм перевода промежуточного потребителя из спящего состояния в активное. 
		1. При восстановлении пропущенных событий:
			1. Запуск внутренней очереди
			2. Чтение оффсета первого элемента очереди
			3. Отправка запроса через модуль работы с состоянием на все данные по текущей очереди начиная со старого оффсета и заканчивая новым.
			4. Скорее всего возвращать все данные разом не нужно, лучше возвращать их чанками через канал, чтобы не забивать локальный кэш