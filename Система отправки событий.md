[[Проекты]]

### Задача
Нужна событийная система, сервисы должны отправлять событие, другие сервисы могут эти события перехватывать для своей логики. Так же нужна система для хранения событий

### Основные компоненты
- Сервис сохранения всех сообщений;
	- сервис создает Exchange (1 или 2)
	- этот сервис имеет свою БД и записывает туда все события;
	- в теории он может выдать эти события обратно в событийную систему;
- Rabbit c exchange;
- Отправители (отправляют сообщения `события` в RabbitMQ);
- Получатели (получают сообщения из RabbitMQ)

### Этапы решения задачи
1. [ ] Реализовать менеджера получателей. В менеджер получателей приходят события от обработчиков gRPC с несколькими типами сообщений. Нужно сделать реакцию на каждый тип сообщения.
	1. [ ] Нужна система регистрации внутренних подписчиков. Это должна быть хэш таблица, в которую должны сохранятся проинициализированные экземпляры [внутренних потребителей]. Для хранения нужно в качестве ключа использовать хэш произведенный из 
	2. Тип сообщения ==новая подписка==:
		1. [ ] Поиск __внутреннего получателя__ по переданной конфигурации. 
			1. [ ] Если получатель найден:
				 - [ ] вызов метода для добавления нового внешнего потребителя внутреннему получателю.
			2.  [ ] Если получатель не найден:
				 - [ ] инициализация получателя,
				 - [ ]  вызов метода для добавления нового внешнего потребителя внутреннему получателю.
	3.  [ ] Тип сообщения ==остановка подписчика== возникает когда внешний подписчик отваливается или заканчивается время ожидания у обработчика gRPC:
		1. [x] Поиск по конфигу нужного отправителя и вызов у него метода остановки промежуточного подписчика (нужно передать имя подписчика)
	4. В начале работы менеджер получателей должен запросить состояние у модуля работы с состоянием.
		1. Передается запрос в модуль состояния.
		2. В модуле состояние делается запрос через модуль БД к самой БД
			1. Если данные есть:
				1. данные возвращаются по каналу в менеджер получателей (менеджер получателей должен ждать ответа)
				2. менеджер получателей создает по полученным данным внутренние очереди (внутренних потребителей) инициализируя их.
					1. в функцию инициализации передается список подписчиков (подписчики будут добавлены в список спящих потребителей, т.е. просто создана структура с именем и оффсетом)
			2. Если данных нет:
				1. менеджер получателей просто переходит в режим ожидания событий от API
3. Реализация внутреннего получателя:
	-  Внутреннему получателю нужны списки (словари) активных подписчиков и спящих подписчиков. 
	-  Метод остановки внутреннего подписчика `sleepConsumer` вызывает метод остановки всех процессов у промежуточного подписчика и перемещает его из списка активных подписчиков в список спящих.
4.  Нужен механизм сохранения состояния. Это должен быть отдельный модуль который подключается к БД и по запросу от модулей, которым нужно сохранять свое состояние, отправлять состояние в БД. У модуля должен быть метод для восстановления состояния системы. Он должен запускаться сразу после запуска сервиса.
	1. В состоянии нужно хранить всех внутренних подписчиков с их конфигом. 
	2. Нужно хранить всех промежуточных подписчиков (имя подписчика, offset последнего не переданного события)
	3. Сохранение состояния должно быть асинхронным, т.е. каждый элемент, которому нужно свое состояние должен сам его сохранять, т.к. есть элементы у которых состояние меняется постоянно, и есть элементы у которых состояние меняется редко.
	4. Нужен метод для восстановления состояния сервиса, он должен быть запущен сразу после запуска сервиса.
Пример структуры
```json
[
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_1": "last_offset",
			"consumer_2": "last_offset",
		},
	},
	{
		"config": { "тут должен быть конфиг"
		},
		
		"consumers": {
			"consumer_5": "last_offset",
			"consumer_6": "last_offset",
		},
	},
]

```
4. [ ] Нужен механизм сохранения событий, которые попадают во внутренний получатель, в БД:
	1. Нужно определиться со структурой БД. Надо понять, создавать ли для каждой очереди свою таблицу, или записывать все очереди в одну таблицу разделенную по партициям;
	2. Нужен механизм записи события очереди в БД
5. [ ] Нужен механизм восстановления очереди, при переподключении внешнего потребителя (т.е. перевод промежуточного потребителя из спящего состояния в активное)
	1. Механизм перевода промежуточного потребителя из спящего состояния в активное. 
		1. При восстановлении пропущенных событий:
			1. Запуск внутренней очереди
			2. Чтение оффсета первого элемента очереди
			3. Отправка запроса через модуль работы с состоянием на все данные по текущей очереди начиная со старого оффсета и заканчивая новым.
			4. Скорее всего возвращать все данные разом не нужно, лучше возвращать их чанками через канал, чтобы не забивать локальный кэш

# Основные задачи

## Сохранение/восстановление состояния 

### Модуль _consumerManagement_

Нужно понять, сколько каналов нужно для общения с модулем состояния.
Основные задачи по работе с состоянием в этом модуле:
- запросы на получение данных:
	- запрос на восстановление состояния, производится из _менеджера потребителей_;
	- запрос на получение очереди из БД, производится конкретной очередью;
- отправка данных:
	- сохранение события, производится из _exchange_
	- сохранение offset события, который был передан внешнему потребителю, отправляет queue.

Событие которое передается из _exchange_ имеет структуру ==СОХРАНЕНИЕ==:
 - id события;
 - id exchange;
 - offset exchange;
 Благодаря такому подходу, само тело события будет сохранено в БД лишь один раз при поступлении от отправителя.

Структура сообщения от queue для сохранения offset переданного события ==СОХРАНЕНИЕ==:
- id очереди;
- name очереди (пока непонятно, на сколько нужно это поле);
- offset события;
Нужно подумать что необходимо для получения очереди, проблема в том, что может прийти запрос на восстановление очереди еще до возникновения _exchange_. Т.е. запрос на восстановление очереди событий с конфигрурацией, с датой начала еще до момента регистрации exchange в маршрутизаторе.

Структура сообщения для восстановления очереди ==ПОЛУЧЕНИЕ==:
1) Вариант стандартный если запрос с API пришел без параметров а очередь уже была создана:
	- offset последнего переданного сообщения (от какого события);
	- offset сообщения которое только что было получено (до какого события) (нужно для получения конечного количества событий);
	- id очереди;
2) Вариант когда пришел offset от API:
	- offset от API (от какого события);
	- offset сообщения которое только что было получено (до какого события);
	-  id очереди;
3) Вариант восстановления очереди с указанием времени от API:
	- time время от API от какого времени нужны события;
	- offset сообщения которое только что было получено (до какого события);
	- id очереди;
	В этом случае есть проблема, если время будет указано до создания exchange то события до создания просто не попадут в выборку. Для выборки которая будет удовлетворять конфигурации exchange нужно сделать запрос в БД с указанием всех необходимых типов событий.

Структура события для восстановления состояния _менеджера потребителей_ ==ПОЛУЧЕНИЕ==.
Для этого не требуются какие либо параметры. Т.к. в любом случае будет исполнен запрос без параметров.

# Структура таблиц в БД
![[Pasted image 20240113194705.png]]

