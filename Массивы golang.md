
Массив - это коллекция однотипных значений фиксированной длины
```go
nums := [5]int{}
```

Если в литерале массива на месте длинны находится ==троеточие==, то длина массива определяется количеством инициализаторов.
```Go
q := [...]int{1, 2, 3}
```

Длина массива указывается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:
```go
nums := [5]int{} // [0, 0, 0, 0, 0]

var nums [5]int // [0, 0, 0, 0, 0]
```

>[!info] Размер массива должен быть константным выражением!
>Т.е. выражением, значение которого может быть вычеслено во время компиляции программы.

>[!info] Если тип элемента массива является сравниваемым, то  таким же является и тип массива

При попытке инициализации элементов за границей массива выходит ошибка компиляции:
```go
nums := [1]int{1, 2} // array index 1 out of bounds [0:1]
```

Чтение и запись элементов массива происходит через квадратные скобки:
```go
nums := [3]int{1, 2, 3}

fmt.Println(nums[1]) // 2

nums[2] = 33

fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0. При попытке чтения/записи элементов за границей массива выходит ошибка компиляции:
```go
words := [2]string{}

words[2] // invalid array index 2 (out of bounds for 2-element array)
```

Массивы в Go передаются по значению, следовательно, любое изменение внутри функции не влияет на исходный массив. ==Это означает, что в функцию передается копия массива==:
```go
package main 

import (
	"fmt"
)

func main() {
	a := [3]int{1, 2, 3}

	midifyArr(a)

	fmt.Println(a) // 1, 2, 3
}

func modifyArr(nums [3]int) {
	nums[0] = 35
}
```



В Go есть встроенная функция len(), которая возвращает длину массива:
```go
fmt.Println(len([5]int{1, 2, 3})) // 5
fmt.Println(len([10]int{})) // 10
```

Массивы одноразмерны, но их можно комбинировать, чтобы получить нужную размерность:
```go
var arr [2][3]int

for i := 0; i < 2; i++ {
	fot j := 0; j < 3; j++ {
		arr[i][j] = i + j
	}
}

fmt.Println("2d:", arr) // 2d: [[0, 1, 2][1, 2, 3]]
```
