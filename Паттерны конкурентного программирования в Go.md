[[многопоточный golang, конкурентность]]
>[!warning]
>Конкурентность является одной из деталей реализации, которые должны быть по возможности скрыты в API. Это позволяет вносить изменения в работу кода, не изменяя то, как он вызывается.

Не следует давать экспортировать каналы, т.е. передавать каналы в общее пользование. Если экспонировать каналы, то это означает, что пользователям придется беспокоится о том, является ли канал буферизованным, закрытым или равным nil.
>[!warning] Каналы не должны быть экспортируемыми

Исключением могут быть только случаи, когда нужно передать каналы в пользование сторонним библиотекам для реализации их функционала.

### Всегда закрывать горутины
При запуске горутин, нужно будет убедиться что они будут закрыты. В отличие от переменных в случае горутин среда выполнения языка Go не сможет проверить, будет ли еще использоваться в программе та или иная горутина. Если горутина не закрыта, то планировщик продолжит периодически предоставлять ей время, которое она не будет использовать, что негативно скажется на производительности программы.
>[!info] Это называется __утечкой горутин__

### Паттерн на основе канала done
___
Паттерн на основе канала _done_ позволяет уведомить горутину о том, что пора прекратить работу.
```Go
func searchData(s string, searchers []func(string) []string) []string {
	done := make(chan struct{}) // нужен только для того чтобы закрыть его
	result := make(chan []string)
	for _, searcher := range searchers {
		go func(searcher func(string) []string) {
			select {
			case result <- searcher(s):
			case <- done: // если канал будет закрыт то чтение из канала вернет nil
			}
		}(searcher)
	}
	r := <-result
	close(done)
	return r
}
```

### Прекращение выполнения горутины с помощью функции отмены
___
```Go
func countTo(max int) (<-chan int, func()) {
	ch := make(chan int)
	done := make(chan struct{})
	cancel := func() {
		close(done)
	}
	go func() {
		for i := 0; i < max; i++ {
			select {
			case <-done:
				break
			default:
				ch <- i
			}
		}
		close(ch)
		return
	}()
	return ch, cancel
}

func main() {
	ch, cancel := countTo(10)
	for i := range ch {
		if i > 5 {
			break
		}
		fmt.Println(i)
	}
	cancel()
}
```
Функция `countTo()` создает два канала, канал для возвращения данных и сигнальный канал `done`. Вместо того чтобы возвращать канал `done` напрямую, мы создаем замыкание, которое закрывает канал `done` и возвращаем это замыкание. 

Схематическое представление:
![[Pasted image 20231025121804.png]]

### Противодавление
```Go
type PressureGauge struct {
	ch chan struct{}
}

func New(limit int) *PressureGauge {
	ch := make(chan struct{}, limit)
	for i := 0; i < limit; i++ {
		ch <- struct{}{}
	}
	return  &PressureGauge{
		ch: ch
	}
}

func (pg *PressureGauge) Process(f func()) error {
	select {
	case <- pg.ch:
		f()
		pg.ch <- struct{}{}
		return nil
	default:
		return errors.New("no more copacity")
	}
}
```
Смысл тут такой: с помощью функции `New()` создается структура `PressureGauge` которая будет содержать _буферизованный канал_ c вместимостью `limit`, который будет полностью заполнен пустыми структурами. Далее можно контролировать количество раз, сколько нам нужно чтобы целевая функция выполнялась (в текущем случае это как раз параметр `limit`). Передавая целевую функцию в метод `Process` мы контролируем количество раз, сколько эта функция может быть вызвана, если структуры в `PressureGauge.ch` закончатся, функцию больше нельзя будет вызвать.