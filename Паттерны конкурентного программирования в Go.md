[[многопоточный golang, конкурентность]]
>[!warning]
>Конкурентность является одной из деталей реализации, которые должны быть по возможности скрыты в API. Это позволяет вносить изменения в работу кода, не изменяя то, как он вызывается.

Не следует давать экспортировать каналы, т.е. передавать каналы в общее пользование. Если экспонировать каналы, то это означает, что пользователям придется беспокоится о том, является ли канал буферизованным, закрытым или равным nil.
>[!warning] Каналы не должны быть экспортируемыми

Исключением могут быть только случаи, когда нужно передать каналы в пользование сторонним библиотекам для реализации их функционала.

### Всегда закрывать горутины
При запуске горутин, нужно будет убедиться что они будут закрыты. В отличие от переменных в случае горутин среда выполнения языка Go не сможет проверить, будет ли еще использоваться в программе та или иная горутина. Если горутина не закрыта, то планировщик продолжит периодически предоставлять ей время, которое она не будет использовать, что негативно скажется на производительности программы.
>[!info] Это называется __утечкой горутин__

### Паттерн на основе канала done
___
Паттерн на основе канала _done_ позволяет уведомить горутину о том, что пора прекратить работу.
```Go
func searchData(s string, searchers []func(string) []string) []string {
	done := make(chan struct{}) // нужен только для того чтобы закрыть его
	result := make(chan []string)
	for _, searcher := range searchers {
		go func(searcher func(string) []string) {
			select {
			case result <- searcher(s):
			case <- done: // если канал будет закрыт то чтение из канала вернет nil
			}
		}(searcher)
	}
	r := <-result
	close(done)
	return r
}
```

### Прекращение выполнения горутины с помощью функции отмены
___
