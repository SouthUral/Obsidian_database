[[многопоточный golang, конкурентность]]

[документ с паттернами многопоточки](https://go.dev/blog/pipelines)
>[!warning]
>Конкурентность является одной из деталей реализации, которые должны быть по возможности скрыты в API. Это позволяет вносить изменения в работу кода, не изменяя то, как он вызывается.

Не следует давать экспортировать каналы, т.е. передавать каналы в общее пользование. Если экспонировать каналы, то это означает, что пользователям придется беспокоится о том, является ли канал буферизованным, закрытым или равным nil.
>[!warning] Каналы не должны быть экспортируемыми

Исключением могут быть только случаи, когда нужно передать каналы в пользование сторонним библиотекам для реализации их функционала.

### Всегда закрывать горутины
При запуске горутин, нужно будет убедиться что они будут закрыты. В отличие от переменных в случае горутин среда выполнения языка Go не сможет проверить, будет ли еще использоваться в программе та или иная горутина. Если горутина не закрыта, то планировщик продолжит периодически предоставлять ей время, которое она не будет использовать, что негативно скажется на производительности программы.
>[!info] Это называется __утечкой горутин__

### Паттерн на основе канала done
___
Паттерн на основе канала _done_ позволяет уведомить горутину о том, что пора прекратить работу.
```Go
func searchData(s string, searchers []func(string) []string) []string {
	done := make(chan struct{}) // нужен только для того чтобы закрыть его
	result := make(chan []string)
	for _, searcher := range searchers {
		go func(searcher func(string) []string) {
			select {
			case result <- searcher(s):
			case <- done: // если канал будет закрыт то чтение из канала вернет nil
			}
		}(searcher)
	}
	r := <-result
	close(done)
	return r
}
```

### Прекращение выполнения горутины с помощью функции отмены
___
```Go
func countTo(max int) (<-chan int, func()) {
	ch := make(chan int)
	done := make(chan struct{})
	cancel := func() {
		close(done)
	}
	go func() {
		for i := 0; i < max; i++ {
			select {
			case <-done:
				break
			default:
				ch <- i
			}
		}
		close(ch)
		return
	}()
	return ch, cancel
}

func main() {
	ch, cancel := countTo(10)
	for i := range ch {
		if i > 5 {
			break
		}
		fmt.Println(i)
	}
	cancel()
}
```
Функция `countTo()` создает два канала, канал для возвращения данных и сигнальный канал `done`. Вместо того чтобы возвращать канал `done` напрямую, мы создаем замыкание, которое закрывает канал `done` и возвращаем это замыкание. 

Схематическое представление:
![[Pasted image 20231025121804.png]]

### Противодавление
___
```Go
type PressureGauge struct {
	ch chan struct{}
}

func New(limit int) *PressureGauge {
	ch := make(chan struct{}, limit)
	for i := 0; i < limit; i++ {
		ch <- struct{}{}
	}
	return  &PressureGauge{
		ch: ch
	}
}

func (pg *PressureGauge) Process(f func()) error {
	select {
	case <- pg.ch:
		f()
		pg.ch <- struct{}{}
		return nil
	default:
		return errors.New("no more copacity")
	}
}
```
Смысл тут такой: с помощью функции `New()` создается структура `PressureGauge` которая будет содержать _буферизованный канал_ c вместимостью `limit`, который будет полностью заполнен пустыми структурами. Далее можно контролировать количество раз, сколько нам нужно чтобы целевая функция выполнялась (в текущем случае это как раз параметр `limit`). Передавая целевую функцию в метод `Process` мы контролируем количество раз, сколько эта функция может быть вызвана, если структуры в `PressureGauge.ch` закончатся, функцию больше нельзя будет вызвать.

### Отключение ветвей оператора select
___
При использовании для чтения из каналов оператора __select__ нужно следить чтобы каналы не закрылись, так как ветвь с закрытым каналом оператора select будет выполнятся всегда.
>[!warning] Чтение из закрытого канала всегда возвращает nil.

В таком случае поможет чтение из `nil` канала, так как оно вызывает вечную блокировку, такая ветвь с чтением из `nil` канала не будет выполнятся. 
>[!warning] Чтение из канала nil никогда не возвращается значение

```go
for {
	select {
	case v, ok := <- in:
		if !ok {
			in = nil // эта ветвь больше не будет успешно выполняться
			continue
		}
	case v, ok := <- in2:
		if !ok {
			in2 = nil
			continue
		}
	case <- done:
		return
	}
}
```

### Тайм-аут для кода
___
```Go
func timeLimit() (int, error) {
	var result int
	var err error
	done := make(chan struct{})
	go func() {
		result, err = doSomeWork()
		close(done)
	}()
	select {
	case <- done:
		return result, err
	case <- time.After(2 * time.Second)
		return 0, errors.New("work time out")
	}
}
```
Этот код ограничивает время выполнения на 2 секунды, если в течении 2-х секунд код в горутине не выполнится то время на выполнение закончится. Если же код в горутине выполнится, то сработает первая ветка select и вернется результат из функции.
>[!warning]
>Если сработает 2 ветвь, т.е. программа будет выполнятся больше двух секунд, то горутина все еще будет продолжать работать, просто с результатом, который она возвратит, уже нельзя будет что-то сделать.

>[!info] Если нужно чтобы горутина прекратила свою работу, когда ответ от нее уже не нужен, то нужно использовать контекстную отмену.

### WaitGroup
___
__WaitGroup__ может понадобиться, когда нужно подождать завершения работы нескольких горутин.

>[!example] Пример простого использования __WaitGroup__.
```Go
func main() {
	var wg sync.WaitGroup
	wg.Add(3)
	go func() {
		defer wg.Done()
		doThing1()
	}()
	go func() {
		defer wg.Done()
		doThing2()
	}()
	go func() {
		defer wg.Done()
		doThong3()
	}()
	wg.Wait()
}
```
В коде объявляется sync.WaitGroup, метод Add() инкрементирует счетчик (по числу запускаемых горутин), далее в каждой горутине метод Done() декрементирует счетчик _(специально вызывается в defer для того чтобы метод сработал в лбом случае, даже при возникновении паники)_. А wg.Wait() ожидает пока счетчик опять будет `0`, после этого основная горутина прекратит работу.
В этом примере тип __sync.WaitGroup__ передается через замыкания, для того чтобы все горутины пользовались одним экземпляром, но можно и явно передать каждой горутине __sync.WaitGroup__ через указатель, в другом случае горутины получат только копию, а значит декрементировать счетчик, который объявлен в основной горутине, они не смогут.

>[!example] Пример с закрытием канала, который используется для записи в нескольких горутнах (если закрыть канал слишком рано и какая-нибудь горутина попытается записать что-то в закрытый канал то возникнет паника).
```Go
func processAndGather(in <-chan int, processor func(int) int, num int) []int {
	out := make(chan int, num)
	var wg sync.WaitGroup
	wg.Add(num)
	for i := 0; i < num; i ++ {
		go func() {
			defer wg.Done()
			for v := range in {
				out <- processor(v)
			}
		}()
	}
	go func() {
		wg.Wait()
		close(out)	
	}()
	var result []int
	for v := range out {
		result = append(result, v)
	}
	return result
}
```
Здесь запускаются `num` количество горутин и запускается счетчик wg.Add(num), сами горутины запускают одну функцию с параметром, которые они забирают из канала `in`, а результаты этой функции они отправляют в канал `out`, из которого уже читает основная горутина и записывает в `result`. За закрытием канала `out` здесь следит еще одна горутина, которая закроет канал, как только счетчик WaitGroup будет ноль.