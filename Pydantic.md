[[Библиотеки Python]]

## Содержание
 - [[Pydantic#Пример модели Pydantic|Пример модели Pydantic]]
 - [[Pydantic#Методы модели|Методы модели]]
 - [[Pydantic#Валидаторы|Валидаторы]]
 - 
 

Pydantic - это библиотека для проверки и анализа данных.
Pydantic предоставляет специальный класс BaseModel, который можно использовать для определения моделей данных и правил их проверки. Правила проверки могут быть определены путём установки типов и ограничений для атрибутов класса.
Эта библиотека также обеспечивает поддержку синтаксического анализа данных из таких источников, как JSON, и может преобразовывать проанализированные данные в экземпляр определённой модели данных. Кроме того, из модели данных можно создать схему JSON, которую можно использовать для проверки входных данных на основе схемы.

### Пример модели Pydantic
```Python

from pydantic import BaseModel 

class User(BaseModel): 
	username = 'username'
	age: int 
	email: str 
	password: str
```
Здесь поле age обязательно для заполнения. Поле username имеет значение по умолчанию, и не обязательно к заполнению
Либо можно записать так:
```python

class User(BaseModel):
	username: str = "username"
	age: int
```

### Методы модели

- ==dict()== - возвращает словарь полей и значений модели;
- ==json()== - возвращает строковое представление модели в json формате, если у модели есть поля, которые так же являются моделями pydantic, то при использовании этого метода будет выведен json с вложенными полями вложенной модели;
```Python

class Genre(BaseModel):
	id: int
	name: str

class Movie(BaseModel):
	id: int
	title: str
	genres: list[Genre]

film_1 = Movie(
	id=1,
	title="Star Wars",
	genres=[Genre(id=2, name="Fantasy"), Genre(id=3, name="Boevik")]
)
print(film_1.json())
```
Вывод:
```Json
{"id": 1, 
 "title": "Star Wars", 
 "genres": [
	 {"id": 2, 
	 "name": "Fantasy"
	 },
	 {"id": 3,
	  "name": "Boevik"}]}
```


- ==parse_obj()== - метод для загрузки любого объекта в модель с обработкой ошибок, 
по сути метод загружает в модель данные из словаря, сопоставляя ключи с полями модели:
```Python

class User(BaseModel):
	id: int
	name: str

u = User.parse_obj({"id":1, "name": "Janin"})
```

- ==parse_raw()== - метод парсит строку, имеющую такую же структуру как словарь:
```Python

class User(BaseModel):
	id: int
	name: str

u = User.parse_raw('{"id":1, "name":"Janin"}')
```

### Валидаторы
Pydantic также предоставляет ряд встроенных средств проверки и ограничений, которые можно использовать для дальнейшего определения и проверки ваших данных. Например, вы можете указать, что поле является обязательным или что оно должно соответствовать определённому шаблону. Вы также можете указать значения по умолчанию для полей, которые пользователь может пропустить.

Вот пример того, как вы можете использовать некоторые из этих функций для дальнейшего определения модели User:

```Python

class User(BaseModel): 
	username: str 
	age: constr(gt=18) 
	email: EmailStr 
	password: constr(min_length=8, max_length=16) 
	phone: Optional[str] = 'Unknown'
```
Здесь используется валидатор ==constr== для определения ограничений для полей ==age== и ==password==.