[[Брокеры сообщений]]

### Полезные ссылки:
 - [официальная документация](https://www.rabbitmq.com/documentation.html)
 - [ссылка на статью на habr](https://habr.com/ru/companies/slurm/articles/703060/)


### Базовая схема всех сущностей RabbitMQ
![[Pasted image 20231004150247.png]]
Слева направо:
 - __Publisher__ - публикует сообщение в ==Exchange== (обменник).
 - __Exchange__ - обменник. Сущность Rabbit, точка входа для публикаций всех сообщений.
 - __Binding__ - связь между __Exchange__ и очередью.
 - __Messages__ - сообщение, атомарная сущность.
 - __Consumer__ - подписчик, получает сообщение из очереди.

Другие термины:
 - __Publishing__ - процесс публикования сообщений в обменник.
 - __Consuming__ - процесс подписывания __consumer__ на очередь и получение им сообщений.
 - __Persistent__ - свойство сохранения данных при перезагрузке сервиса (иначе __стейт__).


---
### Publisher
Создает соединение (__connection__) по протоколу __AMQP__, в рамках соединения создает канал (__chanal__). В рамках одного соединения можно создать несколько каналов, ==но это не рекомендуется==.

> [!info] __Флаппинг каналов__
> Если __Publisher__ для каждого сообщения создаёт соединение (__chanal__) отправляет сообщение, закрывает канал, закрывает соединение - ==это очень плохо==. Rabbit становится плохо уже ~300 таких пересозданий каналов в секунду. Если нет возможности это исправить, то лучше использовать [amqproxy](https://hub.docker.com/r/cloudamqp/amqproxy), но не следует использовать его для __Consumer__.

__Publisher__ может декларировать почти все сущности (exchanges, queues, bindings ...). На практике лучше подходит стратегия декларирования всех нужных сущностей через __consumer__, но для каждого проекта это индивидуально.

> [!info] __Publisher__ всегда пишет в __exchange__

#### Параметры и флаги, которые может устанавливать __publisher__
##### __delivery_mode__
Это "признак персистентности" - означает, что сообщение будет сохранено на диске и не исчезнет в случае перезагрузки Rabbit:
 - __delivery_mode=1__ - не хранить сообщение, (работа идет быстрее);
 - __delivery_mode=2__ - хранить сообщение на диске, (работа идет медленнее, но надежнее).
##### __Routing Key__
__Publisher__ определяет:
 - __delivery_mode__ для каждого сообщения
 - __Routing Key__ для каждого сообщения - признак, по которому идет дальнейшая маршрутизация.
##### __confirm флаг__
__Publisher__ может выставлять ==__confirm флаг__ - отправлять указания Rabbit через отдельный канал подтверждения об успешной приемке сообщений.== Штука полезная, но снижает скорость работы, и трудно реализуется в однопоточных ЯП.

##### __mandatory флаг__
Это указание Rabbit складировать сообщения, не имеющие маршрута в какую-либо очередь в отдельный __Exchange__. Используется редко.


---
### Exchange
_Exchange - это базовая сущность RabbitMQ. Является точкой входа и маршрутизатором всех сообщений (как входящих от __Pablisher__, так и перемещающихся от внутренних процессов в __RabbitMQ__)

> [!info] __Exchange  - это неизменяемая сущность__
> Для изменения параметров __Exchange__ нужно его удалять и декларировать заново.

__Рассылает сообщения во все очереди с подходящим binding__ (но не более одного сообщения в одну очередь, если есть несколько подходящих __binding__).

#### Типы Exchange
- ==Fanout==
- ==Direct==
- ==Topic==
- ==Headers==
##### Fanout
__Exchange__ публикует сообщения во все очереди, в которых есть _binding_, игнорируя любые настройки _binding_ (_routing key_ или заголовки).

Самый простой но не функционально и редко используемый тип. По скорости выдает _30000mps_, столько же выдает тип __Direct__.
![[Pasted image 20231005143321.png]]

##### Direct
__Exchange__ публикует сообщения во все очереди, в которых _routing key binding_ полностью совпадает с _routing key messages_.

Популярный тип, подходит под большинство задач и не проигрывает по скорости типу __Fanout__.
![[Pasted image 20231005143802.png]]

##### Topic
Тип похож на __Direct__ но в качестве параметра поддерживает ==__binding Wildcard__==.

Производительность топика примерно в три раза ниже чем __fanout/direct__ - не более 5000-10000mps.
###### binding Wildcard
Это такой тип параметров где в качестве параметров выступают слова разделенные точкой. Для маршрутизации используются дополнительные символы, которые указывают на то, должно ли быть полное совпадение по одному или нескольким словам, или совпадения по всем словам.
 - (==`*`==) - совпадение одного слова;
 - (==`#`==) - совпадение любого количества слов.

>[!info]- Пояснение
>Если кратко, то работает как простое регулярное выражение, где `*` означает, что на этом месте должно быть одно слово, а `#` означает, что тут может быть любое количество слов

Пример:
![[Pasted image 20231005144928.png]]
Результат:
![[Pasted image 20231005145005.png]]

##### Headers
Наиболее гибкий, но наименее производительный тип. Скорость сильно зависит от сложности условий, поэтому трудно спрогнозировать его скорость работы. В качестве параметров использует заголовки сообщений и _binding_. В _binding_ указываются ожидаемые заголовки и признак ==__x-match__==:
 - __x-match=all__ - необходимы все совпадения для попадания сообщения
 - __x-match=any__ - необходимо хотя бы одно совпадения
Пример:
![[Pasted image 20231005150234.png]]
Результат:
![[Pasted image 20231005150314.png]]

#### Признак персистентности Durable/Transient

__Durable__ - означает, что exchange сохранится после перезагрузки RabbitMQ

> [!info] __Exchange  не подразумевает хранения!__
> Это не очередь. Если маршрут для сообщения не будет найден, сообщение будет сразу отброшено без возможности восстановления.



---
### Binding
![[Pasted image 20231005125826.png]]
==__Binding__== - базовая сущность RabbitMQ, статический маршрут от __Exchange__ до __Queue__ (от обменника до очереди).

> [!info] __Binding - это неизменяемая сущность__!
> Если нужно изменить __Binding__, то его придется удалить и создать новый.

Bindings между парой ==exchange->queue== может быть несколько, но только с разными параметрами.

#### Параметры __Binding__
 - __routingkey__
 - __headers__
 Настраивается один из параметров в зависимости от типа __Exchange__.



---
### Queue (очередь)
Базовая сущность __RabbitMQ__, представляет из себя последовательное хранилище для необработанных сообщений.

Хранение сообщений на диске зависит от флага [[Rabbit MQ#__delivery_mode__|delivery_mode]], назначаемым [[Rabbit MQ#Publisher|Publisher]] для каждого сообщения.

>[!info] Признак персистентности
>__Durable/Transient__ - признак персистентности очереди. __Durable__ означает, что [[Rabbit MQ#Exchange|exchange]] сохранится после перезагрузки __RabbitMQ__.

>[!warning] Важно!!!
>Если отправить сообщение в очередь с признаком [[Rabbit MQ#__delivery_mode__|delivery_mode]]=2 (_persistent_), но очередь задекларирована не как ==__Durable__==, то при перезагрузке __RabbitMQ__, очередь и все содержащиеся в ней сообщения будут безвозвратно утеряны!

#### Типы очередей
 - __Classic__ - обычная очередь, используется часто
 - __Quorum__ - аналог классической очереди, но с обеспечением гарантий консистентности
 - __Stream__ - аналог __Apache Kafka__, здесь все сообщения хранятся в очереди и имеют свой _offset_, подписчик может сообщить с какого _offset_ он хочет получить сообщения, либо указать __last__ (будет означать, что нужны только самые последние сообщения с момента подписки, и далее), либо __first__ (нужны все сообщения начиная с первого)


---
### Message
Это базовая сущность __RabbitMQ__ - само сообщение, несет полезную нагрузку, проходит весь путь от [[Rabbit MQ#Publisher|Publisher]] до [[Rabbit MQ#Consumer|Consumer]].
![[Pasted image 20231005170356.png]]
#### Важные поля:
##### __payload__
>__payload__ - полезная нагрузка, может быть как string так и base64. Можно даже передавать изображения. Теоретический лимит сообщения - 2Gb, но рекомендуемый размер 128mb

##### __routing key__
>__routing key__ - ключ маршрутизации, может быть только один для одного сообщения

##### __delivery_mode__
>Признак персистентности

##### __headers__
>Заголовки сообщения. Нужны для работы [[Rabbit MQ#Exchange|Exchange]] типа [[Rabbit MQ#Headers|Headers]]



---
### Consumer
![[Pasted image 20231005170438.png]]
Это _демон_ который получает сообщение из очереди.
Так же как и [[Rabbit MQ#Publisher|Publisher]], Consumer создает соединение (__connection__) по протоколу __AMQP__. В рамках соединения создает канал (__channel__) и уже инициализирует _consuming_ в рамках этого канала.

__Consumer__ может декларировать практически все сущности - [[Rabbit MQ#Exchange|Exchange]], [[Rabbit MQ#Queue (очередь)|Queue]], [[Rabbit MQ#Binding|Bindings]] и т.д.

__Consumer__ подписывается только на одну очередь. 
>[!info] 
>Если нужно получать сообщения из нескольких очередей, нужно корректно смаршрутизировать их потоки в одну очередь.

__Сообщения в Consumer попадают по push-модели__ - сообщения проталкиваются  Rabbit в канал по мере их появления и (или) освобождения __Consumer__. 

#### Prefetch count
Это параметр __Consumer__. Обозначает количество неподтвержденных __Consumer__ сообщений в один момент. По умолчанию во многих библиотеках он равен ==`0`== . В такой ситуации Rabbit проталкивает все сообщения из очереди в __Consumer__, а тот во многих случаях при достаточно большом количестве сообщений падает.

Пример:
==`Prefetch_count=1`== Означает, что пока __Consumer__ не обработает одно сообщение, следующее к нему не поступит. Как только Rabbit подтвердит обработку, будет сразу получено следующее сообщение.

#### Подтверждение обработки сообщения
__Consumer__ может подтвердить обработку сообщения:  __Acknowledge(ack)__
Или вернуть сообщение в __Queue__ при неудачной обработке: __Negative acknowledge(nack)

Механизм __nack__ также срабатывает автоматически при разрушении канала с __Consumer__. Это удобно использовать: если на горячую выключить Consumer, сообщения, которые, он обрабатывал, автоматически вернутся в очередь.

#### AutoAsk
Это флаг автоматического подтверждения всех проталкиваемых сообщений (не требует __ask__ от __Consumer__ ). Работает быстро, но не дает никаких гарантий успешной обработки сообщений.

### Работа очереди, FIFO очереди
Основу Rabbit представляют собой именно такие очереди:
```
FIFO = first in - first out
```
![[Pasted image 20231006151749.png]]
Попадая в очередь, сообщения выходят из нее в той же последовательности что и вошли. Последовательность определяется моментом попадания сообщения в очередь, не бывает __одновременных сообщений__ в рамках одной очереди, у них всегда есть порядок.
![[Pasted image 20231006151955.png]]
Если мы не укажем prefetch_count, его значение будет равным нулю. Это значит, что все сообщения протолкнутся в Consumer — ничего хорошего обычно в таком поведении нет. _Аналогия: открылся кабинет, и все люди в очереди ввалились туда решать свои вопросы_.
![[Pasted image 20231006152233.png]]
Поэтому мы явно укажем **prefetch_count=1**. Теперь без подтверждения более одного сообщения в Consumer находится не сможет.
![[Pasted image 20231006152303.png]]Далее после успешной обработки Consumer выполняет «ack» для данного сообщения:
![[Pasted image 20231006152331.png]]
Получив ack, Rabbit удалит сообщение из очереди и незамедлительно протолкнёт в Consumer следующее сообщение (и так далее):
![[Pasted image 20231006152410.png]]
А если мы захотим увеличить скорость обработки? Можем поставить в «кабинете» ещё один «стол с врачом». Для этого укажем prefetch_count=2
![[Pasted image 20231006152447.png]]
Теперь будет идти обработка сразу двух сообщений. А если мы хотим быстрее? Добавляем ещё один сonsumer-кабинет (например с prefetch_count=1)
![[Pasted image 20231006152620.png]]