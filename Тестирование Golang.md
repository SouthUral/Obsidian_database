[[Golang]]

### Введение в тестирование

Для тестирования в Golang используется пакет [testing](). Команда `go test` обеспечивает выполнение тестов и генерацию отчетов.

В Golang тесты размещаются в том же каталоге и в том же пакете что и тестируемый код. Этот подход позволяет тестировать неэкспортируемые функции и переменные.

Каждый тест записывается в файле с именем, которое оканчивается на `_test.go`
Пример теста и тестируемой функции:
```go
// код находится в файле adder/adder.go
func addNumbers(x, y int) int {
	return x + y
}
```
Тест:
```go
// тест находится в файле adder/adder_test.go
func Test_addNumber(t *testing.T) {
	result := addNumbers(2, 3)
	if result != 5 {
		t.Error("incorrect result: expected 5, got", result)
	}
}
```

Имена функций теста должны начинаться со слова `Test_` нижнее подчеркивание не обязательно, а после пишется имя функции.
Функция теста принимает один параметр типа `*testing.T`. Функции тестирования не возвращают значения.

Команда `go test` запускает тесты расположенные в текущем каталоге. Так же команда позволяет указать путь до тестов, которые нужно запустить. Можно запустить тесты в текущем и во всех вложенных каталогах добавив к команде флаг
`- v`.

### Тестирование публичного API

Т.к. тесты находятся в том же пакете что и тестируемый код, это позволяет тестировать экспортируемые и неэкспортируемые функции.

Если нужно тестировать только публичное API (это функции, структуру, переменные, все, чье название начинается с большой буквы) то в Go для этого есть способ.

Тесты так же располагаются в том же пакете что и код, но в качестве имени пакета (в файле теста) указывается `имяПакета_test`

Тестируемая функция:
```Go
func AddNumbers(a, b int) int {
	return a + b
}
```

Тест:
```go
package adder_test

import (
	"testing"
	"test_examples/adder"
)

func TestAddNumbers(t *testing.T) {
	result := adder.AddNumbers(2, 3)
	if result != 5 {
		t.Error("incorrect result: expected 5, got", result)
	}
}
```

Фишка в том, что код тестов находится в том же каталоге, но пакет все равно нужно импортировать, будто бы идет импорт из другого каталога.

Использование  имени пакета с суффиксом ==`_test`== позволяет превратить пакет в _черный ящик_ давая возможность взаимодействовать с ним только через экспортируемые функции.

### Сравнение результатов тестов

В простых случаях функции возвращают какой-то простой тип и сравнивать его с тем результатом, который мы ожидаем, достаточно просто. Но если нужно сравнить какой-то составной тип данных (структура со вложенными структурами или другими структурами данных), то тут можно воспользоваться библиотекой [go-cmp](https://github.com/google/go-cmp) , она выполняет сравнение и возвращает пустую строку если все совпало или выдает результат в каких поля какие есть отличия.

Установка пакета: 
```shell
go get -u github.com/google/go-cmp/cmp
```

Код:
```Go
import (
	"time"
)

type Person struct{
	Name string
	Age int
	DateAdded time.Time
}

func CreatePerson(name string, age int) Person {
	return Person{
		Name: name,
		Age: age,
		DateAdded time.Now(),
	}
}
```

В файле теста импортируем пакет [go-cmp](https://github.com/google/go-cmp) 
Тест:
```Go
import (
	"testing"

	cmp "github.com/google/go-cmp/cmp"
)

func TestCreatePerson(t *testing.T) {
	expected := Person{
		Name: "Dennis",
		Age: 37,
	}

	result := CreatePerson("Dennis", 37)
	if diff := cmp.Diff(expected, result); diff != "" {
		t.Error(diff)
	}
}
```

Результат тестов:
```Shell
--- FAIL: TestCreatePerson (0.00s)
    work_person_test.go:16:   workperson.Person{
                Name:      "Dennis",
                Age:       37cmp.Diff,
        -       DateAdded: s"0001-01-01 00:00:00 +0000 UTC",
        +       DateAdded: s"2023-10-12 17:30:05.956216049 +0300 MSK m=+0.000996680",
          }
        
FAIL
FAIL    github.com/SouthUral/go_test/workperson 0.003s
FAIL
```
Строки со знаками ==`-`== ==`+`== указывают, какие поля содержат отличающиеся значения. В данном случае отличается дата создания структуры, это момент невозможно разрешить, т.к. функция `CreatePerson()` не дает возможности устанавливать дату через аргументы и устанавливает ее внутри, нужно проигнорировать поле ==DateAdded==.
Это можно сделать определив функцию-компаратор. Нужно объявить эту функцию локально в тесте как переменную.
```Go
comparer := cmp.Comparer(func(x, y Person) bool {
	return x.Name == y.Name && x.Age == y.Age
})
```

>[!info] Важно
>Функция, которую передали в ==cmp.Comparer== должна принимать аргумента одинакового типа и возвращать булево значение. Она так же должна быть __симметричной__ (_не зависящей от порядка параметров_),__детерминированной__ (_
>всегда возвращающей один и тот же результат для тех же входных данных_) и __чистой__ (_не модифицирующей свои параметры_)


Поменяем вызов функции `cmp.Diff()` передав туда пользовательский компаратор:
```go
import (
	"testing"

	cmp "github.com/google/go-cmp/cmp"
)

func TestCreatePerson(t *testing.T) {
	expected := Person{
		Name: "Dennis",
		Age: 37,
	}

	comparer := cmp.Comparer(func(x, y Person) bool {
		return x.Name == y.Name && x.Age == y.Age
	})
	
	result := CreatePerson("Dennis", 37)
	if diff := cmp.Diff(expected, result, comparer); diff != "" {
		t.Error(diff)
	}
}
```