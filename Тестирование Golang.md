[[Golang]]

### Введение в тестирование

Для тестирования в Golang используется пакет [testing](). Команда `go test` обеспечивает выполнение тестов и генерацию отчетов.

В Golang тесты размещаются в том же каталоге и в том же пакете что и тестируемый код. Этот подход позволяет тестировать неэкспортируемые функции и переменные.

Каждый тест записывается в файле с именем, которое оканчивается на `_test.go`
Пример теста и тестируемой функции:
```go
// код находится в файле adder/adder.go
func addNumbers(x, y int) int {
	return x + y
}
```
Тест:
```go
// тест находится в файле adder/adder_test.go
func Test_addNumber(t *testing.T) {
	result := addNumbers(2, 3)
	if result != 5 {
		t.Error("incorrect result: expected 5, got", result)
	}
}
```

Имена функций теста должны начинаться со слова `Test_` нижнее подчеркивание не обязательно, а после пишется имя функции.
Функция теста принимает один параметр типа `*testing.T`. Функции тестирования не возвращают значения.

Команда `go test` запускает тесты расположенные в текущем каталоге. 
Если нужно запустить тесты в каком-то конкретном каталоге можно указать его расположение через команду `go test ./имя_пакета` - эта команда запустит тесты в дочерней от текущей папке.
Так же команда позволяет указать путь до тестов, которые нужно запустить. Флаг `- v`  можно использовать для получения подробных результатов.

### Печать сообщения о тесте
Для вывода сообщений о не пройденных тестах можно воспользоваться несколькими методами:
```go
func TestExample(t *testing.T) {
	t.Error("text some error", arg) // Этот метод подобен `fmt.Println()` 
	
	t.Errorf("incorrect result %s", arg) // Этот метод работает так же как
	// `fmt.Printf()`
}
```
Эти методы помечают тест как не пройденный, но код дальше все равно продолжает выполняется.
Если нужно остановить выполнение тестов после обнаруженной ошибки, то нужно воспользоваться методом:
```Go
func TestExample(t *testing.T) {
	t.Fatal("text some error", arg)

	t.Fatalf("incorrect result %s", arg)
}
```
Методы работают аналогично, но сразу прекращают работу тестов в этой функции.
>[!info] Важно
>При этом тесты полностью не завершаются, завершается работа только в текущей функции.

Методы ==__t.Fatal / t.Fatalf__==  следует использовать, когда дальнейшее прохождение тестов в текущей функции не имеет смысла, т.е. нарушена функциональность тестируемой функции. Методы ==__t.Error / t.Errorf__== нужно использовать, когда тестируются независимые элементы, например на вход функции передаются различные параметры в одном тесте, или проверяются отдельные возможности функции.
### Тестирование публичного API

Т.к. тесты находятся в том же пакете что и тестируемый код, это позволяет тестировать экспортируемые и неэкспортируемые функции.

Если нужно тестировать только публичное API (это функции, структуру, переменные, все, чье название начинается с большой буквы) то в Go для этого есть способ.

Тесты так же располагаются в том же пакете что и код, но в качестве имени пакета (в файле теста) указывается `имяПакета_test`

Тестируемая функция:
```Go
func AddNumbers(a, b int) int {
	return a + b
}
```

Тест:
```go
package adder_test

import (
	"testing"
	"test_examples/adder"
)

func TestAddNumbers(t *testing.T) {
	result := adder.AddNumbers(2, 3)
	if result != 5 {
		t.Error("incorrect result: expected 5, got", result)
	}
}
```

Фишка в том, что код тестов находится в том же каталоге, но пакет все равно нужно импортировать, будто бы идет импорт из другого каталога.

Использование  имени пакета с суффиксом ==`_test`== позволяет превратить пакет в _черный ящик_ давая возможность взаимодействовать с ним только через экспортируемые функции.

### Сравнение результатов тестов

В простых случаях функции возвращают какой-то простой тип и сравнивать его с тем результатом, который мы ожидаем, достаточно просто. Но если нужно сравнить какой-то составной тип данных (структура со вложенными структурами или другими структурами данных), то тут можно воспользоваться библиотекой [go-cmp](https://github.com/google/go-cmp) , она выполняет сравнение и возвращает пустую строку если все совпало или выдает результат в каких поля какие есть отличия.

Установка пакета: 
```shell
go get -u github.com/google/go-cmp/cmp
```

Код:
```Go
import (
	"time"
)

type Person struct{
	Name string
	Age int
	DateAdded time.Time
}

func CreatePerson(name string, age int) Person {
	return Person{
		Name: name,
		Age: age,
		DateAdded time.Now(),
	}
}
```

В файле теста импортируем пакет [go-cmp](https://github.com/google/go-cmp) 
Тест:
```Go
import (
	"testing"

	cmp "github.com/google/go-cmp/cmp"
)

func TestCreatePerson(t *testing.T) {
	expected := Person{
		Name: "Dennis",
		Age: 37,
	}

	result := CreatePerson("Dennis", 37)
	if diff := cmp.Diff(expected, result); diff != "" {
		t.Error(diff)
	}
}
```

Результат тестов:
```Shell
--- FAIL: TestCreatePerson (0.00s)
    work_person_test.go:16:   workperson.Person{
                Name:      "Dennis",
                Age:       37cmp.Diff,
        -       DateAdded: s"0001-01-01 00:00:00 +0000 UTC",
        +       DateAdded: s"2023-10-12 17:30:05.956216049 +0300 MSK m=+0.000996680",
          }
        
FAIL
FAIL    github.com/SouthUral/go_test/workperson 0.003s
FAIL
```
Строки со знаками ==`-`== ==`+`== указывают, какие поля содержат отличающиеся значения. В данном случае отличается дата создания структуры, это момент невозможно разрешить, т.к. функция `CreatePerson()` не дает возможности устанавливать дату через аргументы и устанавливает ее внутри, нужно проигнорировать поле ==DateAdded==.
Это можно сделать определив функцию-компаратор. Нужно объявить эту функцию локально в тесте как переменную.
```Go
comparer := cmp.Comparer(func(x, y Person) bool {
	return x.Name == y.Name && x.Age == y.Age
})
```

>[!info] Важно
>Функция, которую передали в ==cmp.Comparer== должна принимать аргумента одинакового типа и возвращать булево значение. Она так же должна быть __симметричной__ (_не зависящей от порядка параметров_),__детерминированной__ (_
>всегда возвращающей один и тот же результат для тех же входных данных_) и __чистой__ (_не модифицирующей свои параметры_)


Поменяем вызов функции `cmp.Diff()` передав туда пользовательский компаратор:
```go
import (
	"testing"

	cmp "github.com/google/go-cmp/cmp"
)

func TestCreatePerson(t *testing.T) {
	expected := Person{
		Name: "Dennis",
		Age: 37,
	}

	comparer := cmp.Comparer(func(x, y Person) bool {
		return x.Name == y.Name && x.Age == y.Age
	})
	
	result := CreatePerson("Dennis", 37)
	if diff := cmp.Diff(expected, result, comparer); diff != "" {
		t.Error(diff)
	}
}
```

### Табличные тесты
Табличные тесты используются, когда код нужно проверить на некотором интервале входящих данных. Для табличных тестов используются [[Базовый синтаксис Golang#Структуры#Анонимные структуры|Анонимные структуры]].
```Go
func DoMath(num1, num2 int, op string) (int, error) {
	switch op {
	case "+":
		return num1 + num2, nil
	case "-":
		return num1 - num2, nil
	case "**":
		return num1 * num2, nil
	case "/":
		if num2 == 0 {
			return 0, errors.New("division by zero")
		}
		return num1 / num2, nil
	default:
		return 0, fmt.Errorf("unknow operator %s", op)
	}
}
```
Сделаем срез анонимных структур. Каждая структура будет содержать поля для имени теста, входных параметров, и возвращаемых значений. Каждый элемент среза это отдельный тест:
```go
data := []struct{
	name     string
	num1     int
	num2     int
	op       string
	expected int
	errMsg   string
}{
	{"addition", 2, 2, "+", 4, ""},
	{"subtruction", 2, 2, "-", 0, ""},
	{"multiplication", 2, 2, "*", 4, ""},
	{"division", 2, 2, "/", 1, ""},
	{"bad division", 2, 0, "/", 0, "division by zero"},
	{"unknow operator", 2, 2, ":", 0, "unknow operator :"},
} 
```

### Примечания
>[!info] Фикстуры и данные для тестов
>Если нужно использовать образцы данных для тестирования, то тогда для этих данных нужно создать (в текущем пакете, где находятся тесты) подкаталог ==testdata==.
>Go резервирует это имя каталога для размещения тестовых файлов. При использовании такого каталога, нужно в коде работать с относительными ссылками. 
