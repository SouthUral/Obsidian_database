[[Python]]
[[Библиотеки Python]]

[[type hinting python#Простая аннотация типов|Простая аннотация типов]]
[[type hinting python#Модуль typing|Модуль typing]]
[[type hinting python#Использование статической проверки типов в Python|Использование статической проверки типов в Python]]

>[!note] Запись
>
_Аннотации типов не обеспечивают проверку типов на уровне интерпретатора. Они предназначены для использования разработчиками, средами разработки, линтерами, программами проверки типов и т. д._

## Простая аннотация типов
```python
data: str = "data"
data_2: int = 2
data_l: list[str] = ['1', '2']
```

Аннотация типов в функции:
```python
def function(param: str) -> list[str]:
	return list(param)

def indent_right(s: str, width: int) -> str: 
	return " " * (max(0, width - len(s))) + s
```

Аннотации в классе:
```python
class Book:
	title: str 
	author: str 
	def __init__(self, title: str, author: str) -> None:
		self.title = title
		self.author = author


b: Book = Book(title='Fahrenheit 451', author='Bradbury')
```

Когда может быть сразу несколько типов:
```python
data = str | None
```

## Модуль typing

### Any
Переменная типа `Any` является неограниченной. Поэтому такие переменные совместимы со всеми другими типами (`int`, `str`, `List` и т. д.), а все остальные типы совместимы с ними.
```python
from typing import Any 

result: Any = "SUCCESS" 
# также работает, потому что переменные типа Any совместимы с другими типами 
result = 10 

state: str = "PENDING" 
# работает, потому что все остальные типы совместимы с типом Any. state = result
```

### Literal

Литералы используются для указания программам проверки типов, что значение, которое имеет переменная или функция, равно одному из указанных значений.

```python
from typing import Literal

GENDER = Literal["male", "female", "non–conforming"] 

def create_user(first_name: str, last_name: str, gender: GENDER) –> dict[str, str, GENDER]:
	return {"first_name": first_name, "last_name": last_name, "gender": gender}
	
create_user("John", "Bond", "male")
```

### Union
Иногда переменная может обладать свойствами, охватывающими два объявленных типа. Переменная также может быть двух типов.

```python
from typing import Union def get_room_temperature() –> Union[int, float]: 
	return 20.8 # 20 тоже сработает
```

### TypedDict

Словари, будучи одной из самых простых форм структуры данных в Python, являются одним из наиболее используемых типов переменных в языке.

Использование `TypedDict` может значительно улучшить читаемость кода, особенно в большом проекте, где много объявлений в разных местах; отслеживание того, что куда идет, становится затруднительным по мере изменения размера проекта.

```python
from typing import TypedDict, Union
class Card(TypedDict): 
	rank: Union[str, int] 
	suit: str 
# класс Card теперь имеет поведение обоих классов TypedDict и dict 

# Card может быть использован для аннотации переменной 
ace_of_spade: Card = {'rank': 'A', 'suit': '♤'} 
# или может быть инстанцирован 
ace_of_spade = Card(rank='A', suit='♤')
```

### NoReturn

Тип `NoReturn` аналогичен типу `void` в других языках программирования. Он используется для объявления того, что функция не имеет возврата.

```python
from typing import NoReturn 


def say_greeting() –> NoReturn: 
	print("Hello World!")
```

### Final

Это конструкция типизации, используемая для указания того, что переменная не должна быть повторно назначена или переопределена в подклассе.
```python
from typing import Final


MIN_NAME_LENGTH: Final = 2 

# выдаст ошибку, зафиксированную системой проверки типов 
MIN_NAME_LENGTH += 1 

class Validator(object): 
	MIN_NAME_LENGTH: Final[int] = 4 

class UserValidator(Validator): 
	# эта строка будет отмечена интерпретатором MIN_NAME_LENGTH = 3
	MIN_NAME_LENGTH = 3
```


## Использование статической проверки типов в Python

>[!info]  Использование типа Any 
>Тип `Any` следует использовать только тогда, когда точный тип возвращаемой переменной или параметра функции нам неизвестен; это может быть при использовании сторонней библиотеки, не имеющей аннотаций типов, или при использовании модуля без аннотаций типов.

>[!info] Включите статическую проверку типов 
> Преимущества проверки типов, заключающиеся в предотвращении ошибок и помощи разработчику, будут не так ощутимы, если она будет динамической. Если вы не любите командную строку `mypy`, вы также можете установить его как расширение VSCode или PyCharm.

>[!info] Используйте кортежи для массивов фиксированной длины
> Кортежи выполняют двойную функцию записи. Поэтому, когда у вас есть известное количество элементов в массиве, особенно когда они не все одного типа, для переменной лучше использовать тип кортеж.

>[!info] Типы возврата функций
> Функции должны выполнять одно и только одно действие, поэтому они должны иметь один определенный тип.