[[многопоточный golang, конкурентность]]

[ссылка на статью на хабре](https://habr.com/ru/articles/490336/)
[Видео с канала Николая Тузова](https://www.youtube.com/watch?v=ZTJcaP4G4JM)

### Что такое канал в Golang
___
Каналом в языке Go называется одно- или двунаправленный канал, используемый для организации обмена (то есть приема и передачи) данными между двумя и более go-подпрограммами.

>[!info] Другое объяснение
>Каналы - это механизм взаимодействий между параллельно выполняющимися go-подпрограммами без применения блокировок

>[!info]
>Каналы представляют собой ссылочный тип. Когда передается функции в качестве параметра канал, на самом деле ей передается указатель на канал. И так же как и для map и slice, нулевым значение для  каналов является значение `nil`.

Вместе go-подпрограммы и каналы обеспечивают легковесный (т.е. масштабируемый) способ параллельного выполнения без использования разделяемой памяти и потому не требующий применения блокировок.

Go-подпрограмма создается с помощью инструкций `go` :
```Go
go func(параметры) { блок } (аргументы)

// либо

go функция(аргументы)
```
Инструкция go либо вызывает уже имеющуюся функцию, либо анонимную функцию, созданную на месте вызова инструкции.

Синтаксис работы с каналами:
```go
канал <- значение //Блокирующая передача
<- канал          // Прием данных и их уничтожение
x := <- канал     // Прием и сохранение данных
x, ok := <- канал // Как и выше, полюс проверка - открыт ли канал и имеются ли данные
```

#### Однонаправленные и двунаправленные каналы
___
По умолчанию создаются двунаправленные каналы (т.е. они позволяют посылать и принимать значения), но их можно сделать однонаправленными. Однако очень часто каналы , которые являются полями структур или передаются в виде параметров, являются однонаправленными, т.е. они позволяют либо только посылать либо только принимать значения. В таких случаях семантику использования канала можно выразить (и вынудить компилятор автоматически проверять ее), указывая направления работы канала.
>[!example]
Если значение канала присваивается переменной или полю, либо передается в качестве параметра функции, нужно поставить стрелку перед ключевым словом chan, 
чтобы указать что горутина производит только чтение из канала.
>```go
>func(ch <- chan int) {}

>[!example]
>Чтобы указать, что горутина производит только запись в канал, нужно поставить стрелку после ключевого слова chan
>```go
>func(ch chan <- int) {}
>```

#### Буферизованные и небуферизованные каналы
___
По умолчанию каналы ==__небуферизованные__==. После каждой операции записи в открытый ==небуферизованный канал== производящая запись горутина делает паузу до тех пор, пока другая горутина не произведет чтение из этого канала. И так же для чтения, пока в канал не будет произведена запись, читающая горутина встанет на паузу. Это означает, что для операций записи и чтения в ==небуферизированные каналы== требуется как минимум две горутины.
__Создание небуферизованного канала:__
```Go
ch := make(chan int)
```

Go так же позволяет использовать ==__буферизированные__ каналы==, которые буферизуют без блокировки некоторое ограниченное количество операций записи. Если буфер заполнится еще до выполнения операций чтения из канала, то следующая операция записи в этот канал приостановит записывающую горутину до тех пор, пока не будет произведено чтение из канала. К такой же блокировке приводит попытка чтения из канала с пустым буфером.
Создание буферизованного канала:
```Go
ch := make(chan int, 10)
```

##### Функция len()
___
C помощью функции `len()`можно узнать текущее количество значений в буфере.

##### Функция cap()
___
С помощью функции `cap()` можно узнать максимальный размер буфера канала. Емкость буфера поменять нельзя.

##### Когда нужно применять буферизованные каналы, а когда небуферизованные
___
Для использования __буферизованных__ каналов нужно понять, какого размера поставить буфер. Так же нужно предусмотреть случай, когда буфер канала заполнится, ведь в таком случае записывающая горутина заблокируется до освобождения места в буфере.

### Закрытие канала
___
После завершения записи в канал, его следует закрыть.
```go
close(ch)
```
>[!warning]
>Попытка записи в закрытый канал вызовет панику. Попытка закрыть закрытый канал, так же вызовет панику.

>[!info]
>Попытка чтения из закрытого канала панику не вызовет, если канал был буферизованный, то даже после закрытия из него можно прочитать оставшиеся в нем сообщения. Если же канал бы небуферизованным или в нем не осталось сообщений то будет возвращено нулевое значение для используемого каналом типа.

Проверка закрыт канал или нет:
```Go
mess, ok := <-ch
// ok == true канал открыт
	// ok == false канал закрыт
```

==Задача закрытия канала лежит на горутине, которая производит запись в канал.==

>[!warning]
>При работе с каналами нужно придерживаться двух правил:
> - канал должен закрываться, только если его позднее состояние будет проверяться программой (например с помощью цикла `for`, `select` или операцией приема сообщения `<-`);
> - канал должен закрываться посылающей go-подпрограммой, а не принимающей.
> В общем случае нет смысла закрывать каналы, если их потом никто не проверяет. Т.к. сборщик мусора потом сам уберет каналы, которыми никто не пользуется.

### Оператор select
___
Оператор __select__ - это управляющая конструкция, которая решает проблему, из какого из двух каналов следует прочитать сообщение. 

Оператор __select__ позволяет горутине произвести чтение или запись в один или несколько каналов.
```Go
select {
case v := <-ch1:
	fmt.Println(v)
case v := <-ch2:
	fmt.Println(v)
case ch3 <- x:
	fmt.Println("wrote", x)
case <-ch4:
	fmt.Println("got value from ch4, but ignored it")
}
```
В случае когда сообщение приходит сразу из нескольких каналов, __select__ выберет случайным образом какую ветвь исполнять, это его главное отличие от оператора __switch__.
Использование оператора __select__ исключает вероятность взаимной блокировки горутин.
Так же, после того как одна ветвь будет исполнена оператор __select__ закончит работу и передаст управление потоком далее. Если нужно прочитать данные из всех каналов то можно использовать __select__ вместе с __for__.
>[!info] Такую комбинацию часто называют циклом __for-select__
```Go
for {
	select {
	case <-done:
		return
	case v := <-ch:
		fmt.Println(v)
	}
}
```
Чтобы реализовать неблокирующую операцию чтения или записи в канал, нужно использовать оператор __select__ c ветвью __default__. При отсутствии значения в канале __ch__ следующий код не будет дожидаться того момента, когда из него можно будет произвести чтение, и сразу перейдет к выполнению ветви __default__.
```Go
select {
case v := <-ch:
	fmt.Println(v)
default:
	fmt.Println("no value written to ch")
}
```
>[!warning]
>В большинстве случаев не стоит использовать ветвь __default__ внутри цикла __for-select__. При таком подходе ветвь __default__ будет срабатывать на каждой итерации цикла, когда какая-либо ветвь __case__ не была исполнена. В результате цикл __for__ будет работать непрерывно, повышая расход времени процессора.

### Значения передаваемые в канале
___
Посылка через каналы значений таких типов как `bool`, `int`, `float64`, `string`, совершенно безопасна т.к. посылаются их копии, т.е. полностью отсутствует риск случайного одновременного обращения к одному и тому же значению из нескольких go-подпрограмм. 

Посылка указателей или ссылок через каналы небезопасна, потому что значения, на которые ссылаются указатели или ссылки, могут изменяться посылающей или принимающей go-подпрограммами, поэтому при посылке таких типов сообщений нужно обеспечить поочередный доступ.
Один из способов обеспечить последовательный доступ - использовать ==мьютексы==. Другой в соблюдении правила, согласно которому отправитель не должен обращаться к указателю или ссылке после отправки.

Через каналы так же можно отправлять интерфейсы, то есть значения, реализующие определенный интерфейс. Значения, реализующие интерфейсы, обеспечивающие доступ только для чтения, могут безопасно использоваться любым количеством горутин, но значения, реализующие интерфейсы, которые включают методы для изменения значения, должны обрабатываться подобно указателям - поочередно.

### Различия поведения каналов
![[Pasted image 20231024160300.png]]

>[!warning] Аксиомы каналов
>- Запись в неинициализированный канал блокирует поток навсегда.
>- Чтение из неинициализированного канала блокирует поток навсегда.
>- Запись в закрытый канал вызывает панику.
>- Чтение из закрытого канала дает нулевое значение мгновенно.



